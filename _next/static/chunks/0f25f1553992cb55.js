(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,3018,n=>{"use strict";var e=n.i(1398),s=n.i(8856),t=n.i(2782),r=n.i(7167),l=n.i(8407),i=n.i(1049);let h=t.Layout;function o(n){let t={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",ul:"ul",...(0,s.useMDXComponents)(),...n.components};return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(t.h1,{children:(0,e.jsx)(r.Decl,{s:l.Ot.Glyph})}),"\n",(0,e.jsxs)(t.p,{children:["The type-namespace duplex ",(0,e.jsx)(r.R,{s:l.Ot.Glyph})," defines the datatype, related datatype and operations for OpenType glyphs."]}),"\n",(0,e.jsx)(t.h2,{children:"Glyph Store"}),"\n",(0,e.jsxs)(t.p,{children:["A ",(0,e.jsx)(r.R,{s:l.Ot.Font})," support any datatype implemented ",(0,e.jsx)(r.R,{s:l.Data.OrderStore(l.Ot.Glyph)})," to be the glyph store. ",(0,e.jsx)(t.code,{children:"ot-builder"})," provided ",(0,e.jsx)(r.R,{s:l.Ot.ListGlyphStore})," as the default glyph store implementation."]}),"\n",(0,e.jsxs)(t.h3,{children:["Interface ",(0,e.jsx)(r.Decl,{s:l.Ot.GlyphStore})]}),"\n",(0,e.jsxs)(t.p,{children:["Alias of ",(0,e.jsx)(r.R,{s:l.Data.OrderStore(l.Ot.Glyph)}),"."]}),"\n",(0,e.jsxs)(t.h3,{children:["Interface ",(0,e.jsx)(r.Decl,{s:l.Ot.GlyphStoreFactory((0,i.extend)("GS",l.Ot.GlyphStore))})]}),"\n",(0,e.jsxs)(t.p,{children:["Alias of ",(0,e.jsx)(r.R,{s:l.Data.OrderStoreFactory(l.Ot.Glyph,"GS")}),"."]}),"\n",(0,e.jsxs)(t.h3,{children:["Interface ",(0,e.jsx)(r.Decl,{s:l.Ot.GlyphStoreFactoryWithDefault((0,i.extend)("GS",l.Ot.GlyphStore))})]}),"\n",(0,e.jsxs)(t.p,{children:["Alias of ",(0,e.jsx)(r.R,{s:l.Data.OrderStoreFactoryWithDefault(l.Ot.Glyph,"GS")}),"."]}),"\n",(0,e.jsxs)(t.h3,{children:["Type ",(0,e.jsx)(r.Decl,{s:l.Ot.ListGlyphStore})]}),"\n",(0,e.jsxs)(t.p,{children:["An opaque class that implements ",(0,e.jsx)(r.R,{s:l.Data.OrderStore(l.Ot.Glyph)}),". Created by ",(0,e.jsx)(r.R,{s:l.Ot.ListGlyphStoreFactory}),"."]}),"\n",(0,e.jsxs)(t.h3,{children:["Singleton ",(0,e.jsx)(r.Decl,{s:l.Ot.ListGlyphStoreFactory})]}),"\n",(0,e.jsxs)(t.p,{children:["An opaque factory object that implements ",(0,e.jsx)(r.R,{s:l.Data.OrderStoreFactoryWithDefault(l.Ot.Glyph,l.Ot.ListGlyphStore)}),"."]}),"\n",(0,e.jsx)(t.h2,{children:"Glyph"}),"\n",(0,e.jsxs)(t.h3,{children:["Class ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph})]}),"\n",(0,e.jsxs)(t.p,{children:["The ",(0,e.jsx)(r.R,{s:l.Ot.Glyph})," class represents one glyph. Object identity of ",(0,e.jsx)(r.R,{s:l.Ot.Glyph}),"'s carry the semantics of glyph identity. Many parts of the font, even some geometries inside the glyph, will hold references to ",(0,e.jsx)(r.R,{s:l.Ot.Glyph}),"'s."]}),"\n",(0,e.jsx)(t.h4,{children:"Constructor"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{ctor:!0,s:l.Ot.Glyph.constructor}),"\n",(0,e.jsxs)(t.p,{children:["Create an empty ",(0,e.jsx)(r.R,{s:l.Ot.Glyph}),"."]}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.name,type:l.Data.Maybe(l.string)}),"\n",(0,e.jsx)(t.p,{children:"The glyph name. Optional."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.geometry,type:l.Data.Maybe(l.Ot.Glyph.Geometry)}),"\n",(0,e.jsx)(t.p,{children:"The geometry. Optional. When absent, the glyph is considered a space."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.hints,type:l.Data.Maybe(l.Ot.Glyph.Hints)}),"\n",(0,e.jsx)(t.p,{children:"The hints. Optional."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.horizontal,type:l.Data.Maybe(l.Ot.Glyph.Metric)}),"\n",(0,e.jsx)(t.p,{children:"The horizontal metric."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.vertical,type:l.Data.Maybe(l.Ot.Glyph.Metric)}),"\n",(0,e.jsx)(t.p,{children:"The vertical metric."}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Methods"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{static:!0,s:l.Ot.Glyph.shallowCopy,args:{from:l.Ot.Glyph},returns:l.Ot.Glyph}),"\n",(0,e.jsx)(t.p,{children:"Perform a shallow copy of another glyph."}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h2,{children:"Metrics"}),"\n",(0,e.jsxs)(t.h3,{children:["Datatype ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.Metric})]}),"\n",(0,e.jsx)(t.p,{children:"Defines a metric advance of a glyph."}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.Metric.start,type:l.Ot.Var.Value}),"\n",(0,e.jsx)(t.p,{children:"Start coordinate."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.Metric.end,type:l.Ot.Var.Value}),"\n",(0,e.jsx)(t.p,{children:"End coordinate."}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h2,{children:"Geometry"}),"\n",(0,e.jsxs)(t.h3,{children:["Interface ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.Geometry})]}),"\n",(0,e.jsx)(t.p,{children:"Defines as the union of the following cases."}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.R,{s:l.Ot.Glyph.ContourSet}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.R,{s:l.Ot.Glyph.TtReference}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.R,{s:l.Ot.Glyph.GeometryList}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.GeometryT.type,type:"unique symbol"}),"\n",(0,e.jsx)(t.p,{children:"The type tag of this hint object."}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Case Class ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.ContourSet})," | type = ",(0,e.jsx)(r.R,{s:l.Ot.Glyph.GeometryType.ContourSet})]}),"\n",(0,e.jsx)(t.h4,{children:"Implements"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.R,{s:l.Ot.Glyph.ContourSetProps}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Constructor"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{ctor:!0,s:l.Ot.Glyph.ContourSet.constructor,args:{},returns:l.Ot.Glyph.ContourSet}),"\n",(0,e.jsxs)(t.p,{children:["Creates an ",(0,e.jsx)(r.R,{s:l.Ot.Glyph.ContourSet})," with default implementation."]}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Interface ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.ContourSetProps})]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.ContourSetProps.contours,type:(0,l.array)(l.Ot.Glyph.Contour)}),"\n",(0,e.jsx)(t.p,{children:"The contour set, being a nested array of control knots."}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Case Class ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.TtReference})," | type = ",(0,e.jsx)(r.R,{s:l.Ot.Glyph.GeometryType.TtReference})]}),"\n",(0,e.jsx)(t.h4,{children:"Implements"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.R,{s:l.Ot.Glyph.TtReferenceProps}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Constructor"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{ctor:!0,long:!0,s:l.Ot.Glyph.TtReference.constructor,args:{to:(0,i.annot)(l.Ot.Glyph,"Target glyph"),transform:(0,i.annot)(l.Ot.Glyph.Transform2X3,"Transform of this reference")},returns:l.Ot.Glyph.TtReference}),"\n",(0,e.jsxs)(t.p,{children:["Creates an ",(0,e.jsx)(r.R,{s:l.Ot.Glyph.TrReference})," with default implementation."]}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Interface ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.TtReferenceProps})]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.TtReferenceProps.to,type:l.Ot.Glyph}),"\n",(0,e.jsx)(t.p,{children:"The target glyph."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.TtReferenceProps.transform,type:l.Ot.Glyph.Transform2X3}),"\n",(0,e.jsx)(t.p,{children:"The transform being applied."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.TtReferenceProps.roundXyToGrid,type:l.boolean}),"\n",(0,e.jsx)(t.p,{children:"Whether to round to grid."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.TtReferenceProps.useMyMetrics,type:l.boolean}),"\n",(0,e.jsx)(t.p,{children:"If set, this forces the advance width and left sidebearing for the composite to be equal to those from this original glyph. This works for hinted and unhinted characters."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.TtReferenceProps.pointAttachment,type:l.Data.Maybe(l.Ot.Glyph.PointAttachment)}),"\n",(0,e.jsx)(t.p,{children:"When present, this reference follows TrueType's point-attachment rules."}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Case Class ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.GeometryList})," | type = ",(0,e.jsx)(r.R,{s:l.Ot.Glyph.GeometryType.GeometryList})]}),"\n",(0,e.jsx)(t.h4,{children:"Implements"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.R,{s:l.Ot.Glyph.GeometryListProp}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Constructor"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{ctor:!0,s:l.Ot.Glyph.GeometryList.constructor,args:{items:(0,i.optional)((0,l.array)(l.Ot.Glyph.Geometry))},returns:l.Ot.Glyph.GeometryList}),"\n",(0,e.jsxs)(t.p,{children:["Creates an ",(0,e.jsx)(r.R,{s:l.Ot.Glyph.GeometryList})," from its members."]}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Type ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.GeometryListProp})]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.GeometryList.items,type:l.Ot.Glyph.Geometry}),"\n",(0,e.jsx)(t.p,{children:"The sub items inside."}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h2,{children:"Hints"}),"\n",(0,e.jsxs)(t.h3,{children:["Interface ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.Hint})]}),"\n",(0,e.jsx)(t.p,{children:"Defines as the union of the following cases."}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.R,{s:l.Ot.Glyph.TtInstruction}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.R,{s:l.Ot.Glyph.CffHint}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.Hint.type,type:"unique symbol"}),"\n",(0,e.jsx)(t.p,{children:"The type tag of this hint object."}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Case Class ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.TtInstruction})," | type = ",(0,e.jsx)(r.R,{s:l.Ot.Glyph.HintType.TtInstruction})]}),"\n",(0,e.jsx)(t.h4,{children:"Implements"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.R,{s:l.Ot.Glyph.TtInstructionProps}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Constructor"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{ctor:!0,s:l.Ot.Glyph.TtInstruction.constructor,args:{instructions:"Buffer"}}),"\n",(0,e.jsxs)(t.p,{children:["Creates an ",(0,e.jsx)(r.R,{s:l.Ot.Glyph.TtInstruction})," from a given instruction buffer."]}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Interface ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.TtInstructionProps})]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.TtInstructionProps.instructions,type:"Buffer"}),"\n",(0,e.jsx)(t.p,{children:"The buffer containing the TrueType instructions."}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Case Class ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.CffHint})," | type = ",(0,e.jsx)(r.R,{s:l.Ot.Glyph.HintType.CffHint})]}),"\n",(0,e.jsx)(t.h4,{children:"Implements"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.R,{s:l.Ot.Glyph.CffHintProps}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Constructor"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{ctor:!0,s:l.Ot.Glyph.CffHint.constructor,args:{},returns:l.Ot.Glyph.CffHint}),"\n",(0,e.jsxs)(t.p,{children:["Create an empty ",(0,e.jsx)(r.R,{s:l.Ot.Glyph.CffHint}),"."]}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Interface ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.CffHintProps})]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.CffHintProps.hStems,type:l.Ot.Glyph.CffHintStem}),"\n",(0,e.jsx)(t.p,{children:"The horizontal stems."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.CffHintProps.vStems,type:l.Ot.Glyph.CffHintStem}),"\n",(0,e.jsx)(t.p,{children:"The vertical stems."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.CffHintProps.hintMasks,type:l.Ot.Glyph.CffHintMask}),"\n",(0,e.jsx)(t.p,{children:"The hint masks."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.CffHintProps.counterMasks,type:l.Ot.Glyph.CffHintMask}),"\n",(0,e.jsx)(t.p,{children:"The contour masks."}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Datatype ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.CffHintStem})]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.CffHintStem.start,type:l.Ot.Var}),"\n",(0,e.jsx)(t.p,{children:"Start coordinate of this hint stem."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.CffHintStem.end,type:l.Ot.Var}),"\n",(0,e.jsx)(t.p,{children:"End coordinate of this hint stem."}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Factory Methods"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Fn,{s:l.Ot.Glyph.CffHint.createStem,args:{start:l.Ot.Var.Value,end:l.Ot.Var.Value},returns:l.Ot.Glyph.CffHintStem}),"\n",(0,e.jsxs)(t.p,{children:["Create a ",(0,e.jsx)(r.R,{s:l.Ot.Glyph.CffHintStem}),"."]}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Datatype ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.CffHintMask})]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.CffHintMask.at,type:(0,l.set)(l.Ot.Glyph.PointRef)}),"\n",(0,e.jsx)(t.p,{children:"The point reference right before this hint mask take effect."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.CffHintMask.maskH,type:(0,l.set)(l.Ot.Glyph.CffHintStem)}),"\n",(0,e.jsx)(t.p,{children:"Horizontal stems needed to be enabled."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.CffHintMask.maskH,type:(0,l.set)(l.Ot.Glyph.CffHintStem)}),"\n",(0,e.jsx)(t.p,{children:"Vertical stems needed to be enabled."}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Factory Methods"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Fn,{long:!0,s:l.Ot.Glyph.CffHint.createMask,args:{at:(0,i.annot)(l.Ot.Glyph.PointRef,"Point reference right before this mask"),maskH:(0,i.annot)((0,l.set)(l.Ot.Glyph.CffHintStem),"Horizontal stems to be enabled"),maskV:(0,i.annot)((0,l.set)(l.Ot.Glyph.CffHintStem),"Vertical stems to be enabled")},returns:l.Ot.Glyph.CffHintMask}),"\n",(0,e.jsxs)(t.p,{children:["Create a ",(0,e.jsx)(r.R,{s:l.Ot.Glyph.CffHintMask}),"."]}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h2,{children:"Support Types"}),"\n",(0,e.jsxs)(t.h3,{children:["Datatype ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.Contour})]}),"\n",(0,e.jsxs)(t.p,{children:["Defined as ",(0,e.jsx)(r.R,{s:(0,l.array)(l.Ot.Glyph.Point)}),"."]}),"\n",(0,e.jsxs)(t.h3,{children:["Datatype ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.Point})]}),"\n",(0,e.jsxs)(t.p,{children:[(0,e.jsx)(r.R,{s:l.Ot.Glyph.Point})," defines the datatype of glyph points."]}),"\n",(0,e.jsx)(t.h4,{children:"Factory Methods"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{long:!0,static:!0,s:l.Ot.Glyph.Point.create,args:{x:(0,i.annot)(l.Ot.Var.Value,"X Coordinate"),y:(0,i.annot)(l.Ot.Var.Value,"Y coordinate"),kind:(0,i.optional)((0,i.annot)(l.Ot.Glyph.PointType,"Point Type"))},returns:l.Ot.Glyph.Point}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.Point.x,type:l.Ot.Var.Value}),"\n",(0,e.jsx)(t.p,{children:"X coordinate."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.Point.y,type:l.Ot.Var.Value}),"\n",(0,e.jsx)(t.p,{children:"Y coordinate."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.Point.kind,type:l.Ot.Glyph.PointType}),"\n",(0,e.jsx)(t.p,{children:"Point type."}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Singleton ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.PointOps})]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.PointOps.neutral,type:l.number}),"\n",(0,e.jsxs)(t.p,{children:["The identity of ",(0,e.jsx)(r.R,{s:l.Ot.Glyph.Point}),". Equal to 0."]}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Methods"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{s:l.Ot.Glyph.PointOps.add,args:{x:l.Ot.Glyph.Point,y:l.Ot.Glyph.Point},returns:l.Ot.Glyph.Point}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{s:l.Ot.Glyph.PointOps.negate,args:{x:l.Ot.Glyph.Point},returns:l.Ot.Glyph.Point}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{s:l.Ot.Glyph.PointOps.minus,args:{x:l.Ot.Glyph.Point,y:l.Ot.Glyph.Point},returns:l.Ot.Glyph.Point}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{s:l.Ot.Glyph.PointOps.scale,args:{scale:l.number,y:l.Ot.Glyph.Point},returns:l.Ot.Glyph.Point}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{s:l.Ot.Glyph.PointOps.addScale,args:{x:l.Ot.Glyph.Point,scale:l.number,y:l.Ot.Glyph.Point},returns:l.Ot.Glyph.Point}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{s:l.Ot.Glyph.PointOps.applyTransform,args:{x:l.Ot.Glyph.Point,transform:l.Ot.Glyph.Transform2X3},returns:l.Ot.Glyph.Point}),"\n",(0,e.jsx)(t.p,{children:"Apply a 2×3 transform to a point."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{s:l.Ot.Glyph.PointOps.combineTransform,args:{a:l.Ot.Glyph.Transform2X3,b:l.Ot.Glyph.Transform2X3},returns:l.Ot.Glyph.Transform2X3}),"\n",(0,e.jsxs)(t.p,{children:["Combine two 2×3 transforms together. Applying the combined transform will be equivalent to applying ",(0,e.jsx)(t.em,{children:"b"})," then ",(0,e.jsx)(t.em,{children:"a"}),"."]}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{s:l.Ot.Glyph.PointOps.removeScaledOffset,args:{tfm:l.Ot.Glyph.Transform2X3},returns:l.Ot.Glyph.Transform2X3}),"\n",(0,e.jsxs)(t.p,{children:["Create an equivalent 2×3 transform but without ",(0,e.jsx)(t.code,{children:"scaledOffset"})," property set."]}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Type ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.Transform2X3})]}),"\n",(0,e.jsx)(t.h4,{children:"Constants"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.Transform2X3.Identity,returns:l.Ot.Glyph.Transform2X3}),"\n",(0,e.jsx)(t.p,{children:"The identity transform."}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Factory Methods"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Fn,{s:l.Ot.Glyph.Transform2X3.Scale,args:{s:l.number},returns:l.Ot.Glyph.Transform2X3}),"\n",(0,e.jsx)(t.p,{children:"Creates a uniform scaling transform."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Fn,{s:l.Ot.Glyph.Transform2X3.Translate,args:{dx:l.Ot.Var.Value,dy:l.Ot.Var.Value},returns:l.Ot.Glyph.Transform2X3}),"\n",(0,e.jsx)(t.p,{children:"Creates a translation transform."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Fn,{s:l.Ot.Glyph.Transform2X3.Rotate,args:{angle:l.number},returns:l.Ot.Glyph.Transform2X3}),"\n",(0,e.jsxs)(t.p,{children:["Creates a rotation transform. ",(0,e.jsx)(t.em,{children:"angle"})," is measured in radians, and the positive orientation is counter-clockwise."]}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.Transform2X3.dx,type:l.Ot.Var.Value}),"\n",(0,e.jsx)(t.p,{children:"X offset."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.Transform2X3.dy,type:l.Ot.Var.Value}),"\n",(0,e.jsx)(t.p,{children:"Y offset."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.Transform2X3.xx,type:l.number}),"\n",(0,e.jsx)(t.p,{children:"X scale."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.Transform2X3.yx,type:l.number}),"\n",(0,e.jsx)(t.p,{children:'X shearing. Used by the "Scale10" coefficient in TrueType\'s `glyf`` table.'}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.Transform2X3.xy,type:l.number}),"\n",(0,e.jsx)(t.p,{children:'Y shearing. Used by the "Scale01" coefficient in TrueType\'s `glyf`` table.'}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.Transform2X3.yy,type:l.number}),"\n",(0,e.jsx)(t.p,{children:"Y scale."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.Transform2X3.scaledOffset,type:l.Data.Maybe(l.boolean)}),"\n",(0,e.jsx)(t.p,{children:"Whether the offset is scaled."}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Enumeration ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.PointType})]}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsxs)(t.p,{children:[(0,e.jsx)(r.Item,{s:l.Ot.Glyph.PointType.Corner})," = 0"]}),"\n",(0,e.jsx)(t.p,{children:"This point is corner point."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsxs)(t.p,{children:[(0,e.jsx)(r.Item,{s:l.Ot.Glyph.PointType.Lead})," = 1"]}),"\n",(0,e.jsx)(t.p,{children:"This point is the first control point of a cubic Bezier curve."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsxs)(t.p,{children:[(0,e.jsx)(r.Item,{s:l.Ot.Glyph.PointType.Follow})," = 2"]}),"\n",(0,e.jsx)(t.p,{children:"This point is the second control point of a cubic Bezier curve."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsxs)(t.p,{children:[(0,e.jsx)(r.Item,{s:l.Ot.Glyph.PointType.Quad})," = 3"]}),"\n",(0,e.jsx)(t.p,{children:"This point is an off-curve control point in a quadratic contour, as in TrueType."}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Datatype ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.PointRef})]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.PointRef.geometry,type:l.number}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.PointRef.contour,type:l.number}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.PointRef.index,type:l.number}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Datatype ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.PointIDRef})]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.PointIDRef.pointIndex,type:l.number}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Datatype ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.GlyphPointIDRef})]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.GlyphPointIDRef.glyph,type:l.Ot.Glyph}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.GlyphPointIDRef.pointIndex,type:l.number}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Datatype ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.PointAttachment})]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.PointAttachment.inner,type:l.Ot.Glyph.PointIDRef}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.Glyph.PointAttachment.outer,type:l.Ot.Glyph.PointIDRef}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h2,{children:"Glyph Naming"}),"\n",(0,e.jsxs)(t.h3,{children:["Type ",(0,e.jsx)(r.Decl,{s:l.Ot.GlyphNamingSource})]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.GlyphNamingSource.post,type:l.Data.Maybe(l.Data.Naming.Source(l.Ot.Glyph))}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.GlyphNamingSource.cff,type:l.Data.Maybe(l.Data.Naming.Source(l.Ot.Glyph))}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{readonly:!0,s:l.Ot.GlyphNamingSource.encoding,type:l.Data.Maybe(l.Data.Naming.IndexSource(l.Ot.Glyph))}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Interface ",(0,e.jsx)(r.Decl,{s:l.Ot.GlyphNamer})]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{s:l.Ot.GlyphNamer.nameGlyph,args:{source:l.Ot.GlyphNamingSource,gid:l.number,glyph:l.Ot.Glyph},returns:l.string}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Singleton ",(0,e.jsx)(r.Decl,{s:l.Ot.StandardGlyphNamer})]}),"\n",(0,e.jsxs)(t.p,{children:["The default glyph namer, implements ",(0,e.jsx)(r.R,{s:l.Ot.GlyphNamer}),"."]}),"\n",(0,e.jsxs)(t.h2,{children:["Glyph Stats (namespace ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.Stats}),")"]}),"\n",(0,e.jsxs)(t.h3,{children:["Class ",(0,e.jsx)(r.Decl,{s:l.Ot.Glyph.Stats.BoundingBox})]}),"\n",(0,e.jsx)(t.h4,{children:"Constructor"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{ctor:!0,s:l.Ot.Glyph.Stats.BoundingBox.constructor,args:{xMin:l.number,xMax:l.number,yMin:l.number,yMax:l.number}}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Properties"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.Stats.BoundingBox.xMin,type:l.number}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.Stats.BoundingBox.xMax,type:l.number}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.Stats.BoundingBox.yMin,type:l.number}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Member,{s:l.Ot.Glyph.Stats.BoundingBox.yMax,type:l.number}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h4,{children:"Static Methods"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{static:!0,s:l.Ot.Glyph.Stats.BoundingBox.Blank,returns:l.Ot.Glyph.Stats.BoundingBox}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h2,{children:["Geometry Utilities (namespace ",(0,e.jsx)(r.Decl,{s:l.Ot.GeometryUtil}),")"]}),"\n",(0,e.jsxs)(t.h3,{children:["Interface ",(0,e.jsx)(r.Decl,{s:l.Ot.GeometryUtil.GeometrySink("T")})]}),"\n",(0,e.jsx)(t.h4,{children:"Methods"}),"\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{s:l.Ot.GeometryUtil.GeometrySink.beginContour}),"\n",(0,e.jsx)(t.p,{children:"The callback when a contour begins."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{s:l.Ot.GeometryUtil.GeometrySink.addControlKnot,args:{knot:l.Ot.Glyph.Point}}),"\n",(0,e.jsx)(t.p,{children:"The callback when a control knot (point) is added."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{s:l.Ot.GeometryUtil.GeometrySink.endContour}),"\n",(0,e.jsx)(t.p,{children:"The callback when a contour ends."}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsx)(r.Method,{s:l.Ot.GeometryUtil.GeometrySink.getResult,returns:"T"}),"\n",(0,e.jsx)(t.p,{children:"The callback of returning value."}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.h3,{children:["Interface ",(0,e.jsx)(r.Decl,{s:l.Ot.GeometryUtil.GeometrySinkClass("T")})]}),"\n",(0,e.jsxs)(t.p,{children:["Class that constructs ",(0,e.jsx)(r.R,{s:l.Ot.GeometryUtil.GeometrySink("T")})," instances."]}),"\n",(0,e.jsxs)(t.h3,{children:["Class ",(0,e.jsx)(r.Decl,{s:l.Ot.GeometryUtil.Flattener})]}),"\n",(0,e.jsxs)(t.p,{children:["Implements ",(0,e.jsx)(r.R,{s:l.Ot.GeometryUtil.GeometrySink((0,l.array)((0,l.array)(l.Ot.Glyph.Point)))})]}),"\n",(0,e.jsx)(t.p,{children:"A sink class to flatten the geometry to a contour list."}),"\n",(0,e.jsxs)(t.h3,{children:["Class ",(0,e.jsx)(r.Decl,{s:l.Ot.GeometryUtil.ListPoint})]}),"\n",(0,e.jsxs)(t.p,{children:["Implements ",(0,e.jsx)(r.R,{s:l.Ot.GeometryUtil.GeometrySink((0,l.array)(l.Ot.Glyph.Point))})]}),"\n",(0,e.jsx)(t.p,{children:"A sink class to list the geometry's points"}),"\n",(0,e.jsxs)(t.h3,{children:["Class ",(0,e.jsx)(r.Decl,{s:l.Ot.GeometryUtil.GetBound})]}),"\n",(0,e.jsxs)(t.p,{children:["Implements ",(0,e.jsx)(r.R,{s:l.Ot.GeometryUtil.GeometrySink(l.Ot.Glyph.Stat.BoundingBox)})]}),"\n",(0,e.jsx)(t.p,{children:"A sink class to get the bounding box of a geometry"}),"\n",(0,e.jsxs)(t.h3,{children:["Class ",(0,e.jsx)(r.Decl,{s:l.Ot.GeometryUtil.CountPoint})]}),"\n",(0,e.jsxs)(t.p,{children:["Implements ",(0,e.jsx)(r.R,{s:l.Ot.GeometryUtil.GeometrySink(l.number)})]}),"\n",(0,e.jsx)(t.p,{children:"A sink class to count the geometry's points."}),"\n",(0,e.jsxs)(t.h3,{children:["Function ",(0,e.jsx)(r.Fn,{s:l.Ot.GeometryUtil.apply("T"),args:{cls:l.Ot.GeometryUtil.GeometrySinkClass("T"),geometries:(0,i.rest)((0,l.array)(l.Ot.Glyph.Geometry))},returns:"T"})]}),"\n",(0,e.jsx)(t.p,{children:"Traverse the geometries and use the sink to collect data."})]})}function c(n={}){return(0,e.jsx)(h,{...n,children:(0,e.jsx)(o,{...n})})}n.s(["default",()=>c])},2196,(n,e,s)=>{let t="/references/ot/glyph";(window.__NEXT_P=window.__NEXT_P||[]).push([t,()=>n.r(3018)]),e.hot&&e.hot.dispose(function(){window.__NEXT_P.push([t])})}]);