(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[122],{1445:function(t,e,l){"use strict";l.d(e,{jt:function(){return n},OT:function(){return r},wE:function(){return p},bc:function(){return a},l2:function(){return y},pi:function(){return o},IM:function(){return s},Fp:function(){return i},l7:function(){return m},yA:function(){return u},lo:function(){return k}});var n=function(t){return{optional:t}},r=function(t){return{readonly:t}},p=function(){for(var t=arguments.length,e=new Array(t),l=0;l<t;l++)e[l]=arguments[l];return{either:e}},a=function(){for(var t=arguments.length,e=new Array(t),l=0;l<t;l++)e[l]=arguments[l];return{tuple:e}},y=function(t){for(var e=arguments.length,l=new Array(e>1?e-1:0),n=1;n<e;n++)l[n-1]=arguments[n];return{generic:t,args:l}},o=function(t,e){return{takes:t,returns:e}},s=function(t){return{object:t}},i=function(t,e){return{rawType:t,annotation:e}},m=function(t,e){return{operator:"extends",left:t,right:e}},u=function(t,e){return{operator:"=",left:t,right:e}},k=function(t,e){return{operator:"is",left:t,right:e}}},1781:function(t,e,l){"use strict";l.r(e),l.d(e,{default:function(){return h}});var n=l(3450),r=l(8781),p=(l(7378),l(5318)),a=l(5756),y=l(8810),o=l(4405),s=l(1445);function i(t,e){var l=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),l.push.apply(l,n)}return l}function m(t){for(var e=1;e<arguments.length;e++){var l=null!=arguments[e]?arguments[e]:{};e%2?i(Object(l),!0).forEach((function(e){(0,n.Z)(t,e,l[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(l)):i(Object(l)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(l,e))}))}return t}var u={},k=a.A;function h(t){var e=t.components,l=(0,r.Z)(t,["components"]);return(0,p.kt)(k,m(m(m({},u),l),{},{components:e,mdxType:"MDXLayout"}),(0,p.kt)("h1",null,(0,p.kt)(y.Hf,{s:o.Ot.Glyph,mdxType:"Decl"})),(0,p.kt)("p",null,"The type-namespace duplex ",(0,p.kt)(y.R,{s:o.Ot.Glyph,mdxType:"R"})," defines the datatype, related datatype and operations for OpenType glyphs."),(0,p.kt)("h2",null,"Glyph Store"),(0,p.kt)("p",null,"A ",(0,p.kt)(y.R,{s:o.Ot.Font,mdxType:"R"})," support any datatype implemented ",(0,p.kt)(y.R,{s:o.Vw.OrderStore(o.Ot.Glyph),mdxType:"R"})," to be the glyph store. ",(0,p.kt)("inlineCode",{parentName:"p"},"ot-builder")," provided ",(0,p.kt)(y.R,{s:o.Ot.ListGlyphStore,mdxType:"R"})," as the default glyph store implementation."),(0,p.kt)("h3",null,"Interface ",(0,p.kt)(y.Hf,{s:o.Ot.GlyphStore,mdxType:"Decl"})),(0,p.kt)("p",null,"Alias of ",(0,p.kt)(y.R,{s:o.Vw.OrderStore(o.Ot.Glyph),mdxType:"R"}),"."),(0,p.kt)("h3",null,"Interface ",(0,p.kt)(y.Hf,{s:o.Ot.GlyphStoreFactory((0,s.l7)("GS",o.Ot.GlyphStore)),mdxType:"Decl"})),(0,p.kt)("p",null,"Alias of ",(0,p.kt)(y.R,{s:o.Vw.OrderStoreFactory(o.Ot.Glyph,"GS"),mdxType:"R"}),"."),(0,p.kt)("h3",null,"Interface ",(0,p.kt)(y.Hf,{s:o.Ot.GlyphStoreFactoryWithDefault((0,s.l7)("GS",o.Ot.GlyphStore)),mdxType:"Decl"})),(0,p.kt)("p",null,"Alias of ",(0,p.kt)(y.R,{s:o.Vw.OrderStoreFactoryWithDefault(o.Ot.Glyph,"GS"),mdxType:"R"}),"."),(0,p.kt)("h3",null,"Type ",(0,p.kt)(y.Hf,{s:o.Ot.ListGlyphStore,mdxType:"Decl"})),(0,p.kt)("p",null,"An opaque class that implements ",(0,p.kt)(y.R,{s:o.Vw.OrderStore(o.Ot.Glyph),mdxType:"R"}),". Created by ",(0,p.kt)(y.R,{s:o.Ot.ListGlyphStoreFactory,mdxType:"R"}),"."),(0,p.kt)("h3",null,"Singleton ",(0,p.kt)(y.Hf,{s:o.Ot.ListGlyphStoreFactory,mdxType:"Decl"})),(0,p.kt)("p",null,"An opaque factory object that implements ",(0,p.kt)(y.R,{s:o.Vw.OrderStoreFactoryWithDefault(o.Ot.Glyph,o.Ot.ListGlyphStore),mdxType:"R"}),"."),(0,p.kt)("h2",null,"Glyph"),(0,p.kt)("h3",null,"Class ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph,mdxType:"Decl"})),(0,p.kt)("p",null,"The ",(0,p.kt)(y.R,{s:o.Ot.Glyph,mdxType:"R"})," class represents one glyph. Object identity of ",(0,p.kt)(y.R,{s:o.Ot.Glyph,mdxType:"R"}),"'s carry the semantics of glyph identity. Many parts of the font, even some geometries inside the glyph, will hold references to ",(0,p.kt)(y.R,{s:o.Ot.Glyph,mdxType:"R"}),"'s."),(0,p.kt)("h4",null,"Constructor"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{ctor:!0,s:o.Ot.Glyph.constructor,mdxType:"Method"}),(0,p.kt)("p",{parentName:"li"}," Create an empty ",(0,p.kt)(y.R,{s:o.Ot.Glyph,mdxType:"R"}),"."))),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.name,type:o.Vw.Maybe(o.Z_),mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," The glyph name. Optional.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.geometry,type:o.Vw.Maybe(o.Ot.Glyph.Geometry),mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," The geometry. Optional. When absent, the glyph is considered a space.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.hints,type:o.Vw.Maybe(o.Ot.Glyph.Hints),mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," The hints. Optional.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.horizontal,type:o.Vw.Maybe(o.Ot.Glyph.Metric),mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," The horizontal metric.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.vertical,type:o.Vw.Maybe(o.Ot.Glyph.Metric),mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," The vertical metric."))),(0,p.kt)("h4",null,"Methods"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{static:!0,s:o.Ot.Glyph.shallowCopy,args:{from:o.Ot.Glyph},returns:o.Ot.Glyph,mdxType:"Method"}),(0,p.kt)("p",{parentName:"li"},"Perform a shallow copy of another glyph."))),(0,p.kt)("h2",null,"Metrics"),(0,p.kt)("h3",null,"Datatype ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.Metric,mdxType:"Decl"})),(0,p.kt)("p",null,"Defines a metric advance of a glyph."),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.Metric.start,type:o.Ot.Var.Value,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," Start coordinate.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.Metric.end,type:o.Ot.Var.Value,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," End coordinate."))),(0,p.kt)("h2",null,"Geometry"),(0,p.kt)("h3",null,"Interface ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.Geometry,mdxType:"Decl"})),(0,p.kt)("p",null,"Defines as the union of the following cases."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.R,{s:o.Ot.Glyph.ContourSet,mdxType:"R"})),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.R,{s:o.Ot.Glyph.TtReference,mdxType:"R"})),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.R,{s:o.Ot.Glyph.GeometryList,mdxType:"R"}))),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.GeometryT.type,type:"unique symbol",mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"},"The type tag of this hint object."))),(0,p.kt)("h3",null,"Case Class ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.ContourSet,mdxType:"Decl"})," | type = ",(0,p.kt)(y.R,{s:o.Ot.Glyph.GeometryType.ContourSet,mdxType:"R"})),(0,p.kt)("h4",null,"Implements"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.R,{s:o.Ot.Glyph.ContourSetProps,mdxType:"R"}))),(0,p.kt)("h4",null,"Constructor"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{ctor:!0,s:o.Ot.Glyph.ContourSet.constructor,args:{},returns:o.Ot.Glyph.ContourSet,mdxType:"Method"}),(0,p.kt)("p",{parentName:"li"}," Creates an ",(0,p.kt)(y.R,{s:o.Ot.Glyph.ContourSet,mdxType:"R"})," with default implementation."))),(0,p.kt)("h3",null,"Interface ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.ContourSetProps,mdxType:"Decl"})),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.ContourSetProps.contours,type:(0,o.IX)(o.Ot.Glyph.Contour),mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," The contour set, being a nested array of control knots."))),(0,p.kt)("h3",null,"Case Class ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.TtReference,mdxType:"Decl"})," | type = ",(0,p.kt)(y.R,{s:o.Ot.Glyph.GeometryType.TtReference,mdxType:"R"})),(0,p.kt)("h4",null,"Implements"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.R,{s:o.Ot.Glyph.TtReferenceProps,mdxType:"R"}))),(0,p.kt)("h4",null,"Constructor"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{ctor:!0,long:!0,s:o.Ot.Glyph.TtReference.constructor,args:{to:(0,s.Fp)(o.Ot.Glyph,"Target glyph"),transform:(0,s.Fp)(o.Ot.Glyph.Transform2X3,"Transform of this reference")},returns:o.Ot.Glyph.TtReference,mdxType:"Method"}),(0,p.kt)("p",{parentName:"li"},"  Creates an ",(0,p.kt)(y.R,{s:o.Ot.Glyph.TrReference,mdxType:"R"})," with default implementation."))),(0,p.kt)("h3",null,"Interface ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.TtReferenceProps,mdxType:"Decl"})),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.TtReferenceProps.to,type:o.Ot.Glyph,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," The target glyph.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.TtReferenceProps.transform,type:o.Ot.Glyph.Transform2X3,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," The transform being applied.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.TtReferenceProps.roundXyToGrid,type:o.O7,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," Whether to round to grid.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.TtReferenceProps.useMyMetrics,type:o.O7,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," If set, this forces the advance width and left sidebearing for the composite to be equal to those from this original glyph. This works for hinted and unhinted characters.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.TtReferenceProps.pointAttachment,type:o.Vw.Maybe(o.Ot.Glyph.PointAttachment),mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," When present, this reference follows TrueType's point-attachment rules."))),(0,p.kt)("h3",null,"Case Class ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.GeometryList,mdxType:"Decl"})," | type = ",(0,p.kt)(y.R,{s:o.Ot.Glyph.GeometryType.GeometryList,mdxType:"R"})),(0,p.kt)("h4",null,"Implements"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.R,{s:o.Ot.Glyph.GeometryListProp,mdxType:"R"}))),(0,p.kt)("h4",null,"Constructor"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{ctor:!0,s:o.Ot.Glyph.GeometryList.constructor,args:{items:(0,s.jt)((0,o.IX)(o.Ot.Glyph.Geometry))},returns:o.Ot.Glyph.GeometryList,mdxType:"Method"}),(0,p.kt)("p",{parentName:"li"}," Creates an ",(0,p.kt)(y.R,{s:o.Ot.Glyph.GeometryList,mdxType:"R"})," from its members."))),(0,p.kt)("h3",null,"Type ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.GeometryListProp,mdxType:"Decl"})),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.GeometryList.items,type:o.Ot.Glyph.Geometry,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," The sub items inside."))),(0,p.kt)("h2",null,"Hints"),(0,p.kt)("h3",null,"Interface ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.Hint,mdxType:"Decl"})),(0,p.kt)("p",null,"Defines as the union of the following cases."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.R,{s:o.Ot.Glyph.TtInstruction,mdxType:"R"})),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.R,{s:o.Ot.Glyph.CffHint,mdxType:"R"}))),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.Hint.type,type:"unique symbol",mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"},"The type tag of this hint object."))),(0,p.kt)("h3",null,"Case Class ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.TtInstruction,mdxType:"Decl"})," | type = ",(0,p.kt)(y.R,{s:o.Ot.Glyph.HintType.TtInstruction,mdxType:"R"})),(0,p.kt)("h4",null,"Implements"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.R,{s:o.Ot.Glyph.TtInstructionProps,mdxType:"R"}))),(0,p.kt)("h4",null,"Constructor"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{ctor:!0,s:o.Ot.Glyph.TtInstruction.constructor,args:{instructions:"Buffer"},mdxType:"Method"}),(0,p.kt)("p",{parentName:"li"}," Creates an ",(0,p.kt)(y.R,{s:o.Ot.Glyph.TtInstruction,mdxType:"R"})," from a given instruction buffer."))),(0,p.kt)("h3",null,"Interface ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.TtInstructionProps,mdxType:"Decl"})),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.TtInstructionProps.instructions,type:"Buffer",mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," The buffer containing the TrueType instructions."))),(0,p.kt)("h3",null,"Case Class ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.CffHint,mdxType:"Decl"})," | type = ",(0,p.kt)(y.R,{s:o.Ot.Glyph.HintType.CffHint,mdxType:"R"})),(0,p.kt)("h4",null,"Implements"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.R,{s:o.Ot.Glyph.CffHintProps,mdxType:"R"}))),(0,p.kt)("h4",null,"Constructor"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{ctor:!0,s:o.Ot.Glyph.CffHint.constructor,args:{},returns:o.Ot.Glyph.CffHint,mdxType:"Method"}),(0,p.kt)("p",{parentName:"li"}," Create an empty ",(0,p.kt)(y.R,{s:o.Ot.Glyph.CffHint,mdxType:"R"}),"."))),(0,p.kt)("h3",null,"Interface ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.CffHintProps,mdxType:"Decl"})),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.CffHintProps.hStems,type:o.Ot.Glyph.CffHintStem,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," The horizontal stems.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.CffHintProps.vStems,type:o.Ot.Glyph.CffHintStem,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," The vertical stems.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.CffHintProps.hintMasks,type:o.Ot.Glyph.CffHintMask,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," The hint masks.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.CffHintProps.counterMasks,type:o.Ot.Glyph.CffHintMask,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," The contour masks."))),(0,p.kt)("h3",null,"Datatype ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.CffHintStem,mdxType:"Decl"})),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.CffHintStem.start,type:o.Ot.Var,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," Start coordinate of this hint stem.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.CffHintStem.end,type:o.Ot.Var,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," End coordinate of this hint stem."))),(0,p.kt)("h4",null,"Factory Methods"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Fn,{s:o.Ot.Glyph.CffHint.createStem,args:{start:o.Ot.Var.Value,end:o.Ot.Var.Value},returns:o.Ot.Glyph.CffHintStem,mdxType:"Fn"}),(0,p.kt)("p",{parentName:"li"}," Create a ",(0,p.kt)(y.R,{s:o.Ot.Glyph.CffHintStem,mdxType:"R"}),"."))),(0,p.kt)("h3",null,"Datatype ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.CffHintMask,mdxType:"Decl"})),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.CffHintMask.at,type:(0,o.t8)(o.Ot.Glyph.PointRef),mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," The point reference right before this hint mask take effect.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.CffHintMask.maskH,type:(0,o.t8)(o.Ot.Glyph.CffHintStem),mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," Horizontal stems needed to be enabled.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{s:o.Ot.Glyph.CffHintMask.maskH,type:(0,o.t8)(o.Ot.Glyph.CffHintStem),mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," Vertical stems needed to be enabled."))),(0,p.kt)("h4",null,"Factory Methods"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Fn,{long:!0,s:o.Ot.Glyph.CffHint.createMask,args:{at:(0,s.Fp)(o.Ot.Glyph.PointRef,"Point reference right before this mask"),maskH:(0,s.Fp)((0,o.t8)(o.Ot.Glyph.CffHintStem),"Horizontal stems to be enabled"),maskV:(0,s.Fp)((0,o.t8)(o.Ot.Glyph.CffHintStem),"Vertical stems to be enabled")},returns:o.Ot.Glyph.CffHintMask,mdxType:"Fn"}),(0,p.kt)("p",{parentName:"li"}," Create a ",(0,p.kt)(y.R,{s:o.Ot.Glyph.CffHintMask,mdxType:"R"}),"."))),(0,p.kt)("h2",null,"Support Types"),(0,p.kt)("h3",null,"Datatype ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.Contour,mdxType:"Decl"})),(0,p.kt)("p",null,"Defined as ",(0,p.kt)(y.R,{s:(0,o.IX)(o.Ot.Glyph.Point),mdxType:"R"}),"."),(0,p.kt)("h3",null,"Datatype ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.Point,mdxType:"Decl"})),(0,p.kt)(y.R,{s:o.Ot.Glyph.Point,mdxType:"R"})," defines the datatype of glyph points.",(0,p.kt)("h4",null,"Factory Methods"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{long:!0,static:!0,s:o.Ot.Glyph.Point.create,args:{x:(0,s.Fp)(o.Ot.Var.Value,"X Coordinate"),y:(0,s.Fp)(o.Ot.Var.Value,"Y coordinate"),kind:(0,s.jt)((0,s.Fp)(o.Ot.Glyph.PointType,"Point Type"))},returns:o.Ot.Glyph.Point,mdxType:"Method"}))),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.Point.x,type:o.Ot.Var.Value,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," X coordinate.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.Point.y,type:o.Ot.Var.Value,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," Y coordinate.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.Point.kind,type:o.Ot.Glyph.PointType,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," Point type."))),(0,p.kt)("h3",null,"Singleton ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.PointOps,mdxType:"Decl"})),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.PointOps.neutral,type:o.Rx,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," The identity of ",(0,p.kt)(y.R,{s:o.Ot.Glyph.Point,mdxType:"R"}),". Equal to 0."))),(0,p.kt)("h4",null,"Methods"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{s:o.Ot.Glyph.PointOps.add,args:{x:o.Ot.Glyph.Point,y:o.Ot.Glyph.Point},returns:o.Ot.Glyph.Point,mdxType:"Method"})),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{s:o.Ot.Glyph.PointOps.negate,args:{x:o.Ot.Glyph.Point},returns:o.Ot.Glyph.Point,mdxType:"Method"})),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{s:o.Ot.Glyph.PointOps.minus,args:{x:o.Ot.Glyph.Point,y:o.Ot.Glyph.Point},returns:o.Ot.Glyph.Point,mdxType:"Method"})),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{s:o.Ot.Glyph.PointOps.scale,args:{scale:o.Rx,y:o.Ot.Glyph.Point},returns:o.Ot.Glyph.Point,mdxType:"Method"})),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{s:o.Ot.Glyph.PointOps.addScale,args:{x:o.Ot.Glyph.Point,scale:o.Rx,y:o.Ot.Glyph.Point},returns:o.Ot.Glyph.Point,mdxType:"Method"})),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{s:o.Ot.Glyph.PointOps.applyTransform,args:{x:o.Ot.Glyph.Point,transform:o.Ot.Glyph.Transform2X3},returns:o.Ot.Glyph.Point,mdxType:"Method"}),(0,p.kt)("p",{parentName:"li"},"Apply a 2\xd73 transform to a point.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{s:o.Ot.Glyph.PointOps.combineTransform,args:{a:o.Ot.Glyph.Transform2X3,b:o.Ot.Glyph.Transform2X3},returns:o.Ot.Glyph.Transform2X3,mdxType:"Method"}),(0,p.kt)("p",{parentName:"li"},"Combine two 2\xd73 transforms together. Applying the combined transform will be equivalent to applying ",(0,p.kt)("em",{parentName:"p"},"b")," then ",(0,p.kt)("em",{parentName:"p"},"a"),".")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{s:o.Ot.Glyph.PointOps.removeScaledOffset,args:{tfm:o.Ot.Glyph.Transform2X3},returns:o.Ot.Glyph.Transform2X3,mdxType:"Method"}),(0,p.kt)("p",{parentName:"li"},"Create an equivalent 2\xd73 transform but without ",(0,p.kt)("inlineCode",{parentName:"p"},"scaledOffset")," property set."))),(0,p.kt)("h3",null,"Type ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.Transform2X3,mdxType:"Decl"})),(0,p.kt)("h4",null,"Constants"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Hf,{s:o.Ot.Glyph.Transform2X3.Identity,returns:o.Ot.Glyph.Transform2X3,mdxType:"Decl"}),(0,p.kt)("p",{parentName:"li"},"The identity transform."))),(0,p.kt)("h4",null,"Factory Methods"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Fn,{s:o.Ot.Glyph.Transform2X3.Scale,args:{s:o.Rx},returns:o.Ot.Glyph.Transform2X3,mdxType:"Fn"}),(0,p.kt)("p",{parentName:"li"},"Creates a uniform scaling transform.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Fn,{s:o.Ot.Glyph.Transform2X3.Translate,args:{dx:o.Ot.Var.Value,dy:o.Ot.Var.Value},returns:o.Ot.Glyph.Transform2X3,mdxType:"Fn"}),(0,p.kt)("p",{parentName:"li"},"Creates a translation transform.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Fn,{s:o.Ot.Glyph.Transform2X3.Rotate,args:{angle:o.Rx},returns:o.Ot.Glyph.Transform2X3,mdxType:"Fn"}),(0,p.kt)("p",{parentName:"li"},"Creates a rotation transform. ",(0,p.kt)("em",{parentName:"p"},"angle")," is measured in radians, and the positive orientation is counter-clockwise."))),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.Transform2X3.dx,type:o.Ot.Var.Value,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"},"X offset.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.Transform2X3.dy,type:o.Ot.Var.Value,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"},"Y offset.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.Transform2X3.xx,type:o.Rx,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"},"X scale.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.Transform2X3.yx,type:o.Rx,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"},"X shearing.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.Transform2X3.xy,type:o.Rx,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"},"Y shearing.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.Transform2X3.yy,type:o.Rx,mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"},"Y scale.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.Transform2X3.scaledOffset,type:o.Vw.Maybe(o.O7),mdxType:"Member"}),(0,p.kt)("p",{parentName:"li"}," Whether the offset is scaled."))),(0,p.kt)("h3",null,"Enumeration ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.PointType,mdxType:"Decl"})),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.ck,{s:o.Ot.Glyph.PointType.Corner,mdxType:"Item"})," = 0",(0,p.kt)("p",{parentName:"li"}," This point is corner point.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.ck,{s:o.Ot.Glyph.PointType.Lead,mdxType:"Item"})," = 1",(0,p.kt)("p",{parentName:"li"}," This point is the first control point of a cubic Bezier curve.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.ck,{s:o.Ot.Glyph.PointType.Follow,mdxType:"Item"})," = 2",(0,p.kt)("p",{parentName:"li"}," This point is the second control point of a cubic Bezier curve.")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.ck,{s:o.Ot.Glyph.PointType.Quad,mdxType:"Item"})," = 3",(0,p.kt)("p",{parentName:"li"}," This point is an off-curve control point in a quadratic contour, as in TrueType."))),(0,p.kt)("h3",null,"Datatype ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.PointRef,mdxType:"Decl"})),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.PointRef.geometry,type:o.Rx,mdxType:"Member"})),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.PointRef.contour,type:o.Rx,mdxType:"Member"})),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.PointRef.index,type:o.Rx,mdxType:"Member"}))),(0,p.kt)("h3",null,"Datatype ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.PointIDRef,mdxType:"Decl"})),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.PointIDRef.pointIndex,type:o.Rx,mdxType:"Member"}))),(0,p.kt)("h3",null,"Datatype ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.GlyphPointIDRef,mdxType:"Decl"})),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.GlyphPointIDRef.glyph,type:o.Ot.Glyph,mdxType:"Member"})),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.GlyphPointIDRef.pointIndex,type:o.Rx,mdxType:"Member"}))),(0,p.kt)("h3",null,"Datatype ",(0,p.kt)(y.Hf,{s:o.Ot.Glyph.PointAttachment,mdxType:"Decl"})),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.PointAttachment.inner,type:o.Ot.Glyph.PointIDRef,mdxType:"Member"})),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.Glyph.PointAttachment.outer,type:o.Ot.Glyph.PointIDRef,mdxType:"Member"}))),(0,p.kt)("h2",null,"Glyph Naming"),(0,p.kt)("h3",null,"Type ",(0,p.kt)(y.Hf,{s:o.Ot.GlyphNamingSource,mdxType:"Decl"})),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.GlyphNamingSource.post,type:o.Vw.Maybe(o.Vw.Naming.Source(o.Ot.Glyph)),mdxType:"Member"})),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.GlyphNamingSource.cff,type:o.Vw.Maybe(o.Vw.Naming.Source(o.Ot.Glyph)),mdxType:"Member"})),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.Nw,{readonly:!0,s:o.Ot.GlyphNamingSource.encoding,type:o.Vw.Maybe(o.Vw.Naming.IndexSource(o.Ot.Glyph)),mdxType:"Member"}))),(0,p.kt)("h3",null,"Interface ",(0,p.kt)(y.Hf,{s:o.Ot.GlyphNamer,mdxType:"Decl"})),(0,p.kt)("h4",null,"Properties"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)(y.n$,{s:o.Ot.GlyphNamer.nameGlyph,args:{source:o.Ot.GlyphNamingSource,gid:o.Rx,glyph:o.Ot.Glyph},returns:o.Z_,mdxType:"Method"}))),(0,p.kt)("h3",null,"Singleton ",(0,p.kt)(y.Hf,{s:o.Ot.StandardGlyphNamer,mdxType:"Decl"})),(0,p.kt)("p",null,"The default glyph namer, implements ",(0,p.kt)(y.R,{s:o.Ot.GlyphNamer,mdxType:"R"}),"."))}h.isMDXComponent=!0},3327:function(t,e,l){(window.__NEXT_P=window.__NEXT_P||[]).push(["/references/ot/glyph",function(){return l(1781)}])}},function(t){t.O(0,[774,311,888,179],(function(){return e=3327,t(t.s=e);var e}));var e=t.O();_N_E=e}]);