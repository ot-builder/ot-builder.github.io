(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[122],{2341:function(n,s,e){(window.__NEXT_P=window.__NEXT_P||[]).push(["/references/ot/glyph",function(){return e(6507)}])},4234:function(n,s,e){"use strict";e.d(s,{Fp:function(){return x},IM:function(){return c},OT:function(){return l},RF:function(){return r},bc:function(){return h},jt:function(){return t},l2:function(){return o},l7:function(){return j},lo:function(){return d},pi:function(){return p},wE:function(){return i},yA:function(){return y}});let t=n=>({optional:n}),r=n=>({rest:n}),l=n=>({readonly:n}),i=function(){for(var n=arguments.length,s=Array(n),e=0;e<n;e++)s[e]=arguments[e];return{either:s}},h=function(){for(var n=arguments.length,s=Array(n),e=0;e<n;e++)s[e]=arguments[e];return{tuple:s}},o=function(n){for(var s=arguments.length,e=Array(s>1?s-1:0),t=1;t<s;t++)e[t-1]=arguments[t];return{generic:n,args:e}},p=(n,s)=>({takes:n,returns:s}),c=n=>({object:n}),x=(n,s)=>({rawType:n,annotation:s}),j=(n,s)=>({operator:"extends",left:n,right:s}),y=(n,s)=>({operator:"=",left:n,right:s}),d=(n,s)=>({operator:"is",left:n,right:s})},6507:function(n,s,e){"use strict";e.r(s);var t=e(4246),r=e(1670),l=e(9790),i=e(4017),h=e(5307),o=e(4234);let p=l.A;function c(n){let s=Object.assign({h1:"h1",p:"p",h2:"h2",code:"code",h3:"h3",h4:"h4",ul:"ul",li:"li",em:"em"},(0,r.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{children:(0,t.jsx)(i.Hf,{s:h.Ot.Glyph})}),"\n",(0,t.jsxs)(s.p,{children:["The type-namespace duplex ",(0,t.jsx)(i.R,{s:h.Ot.Glyph})," defines the datatype, related datatype and operations for OpenType glyphs."]}),"\n",(0,t.jsx)(s.h2,{children:"Glyph Store"}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(i.R,{s:h.Ot.Font})," support any datatype implemented ",(0,t.jsx)(i.R,{s:h.Vw.OrderStore(h.Ot.Glyph)})," to be the glyph store. ",(0,t.jsx)(s.code,{children:"ot-builder"})," provided ",(0,t.jsx)(i.R,{s:h.Ot.ListGlyphStore})," as the default glyph store implementation."]}),"\n",(0,t.jsxs)(s.h3,{children:["Interface ",(0,t.jsx)(i.Hf,{s:h.Ot.GlyphStore})]}),"\n",(0,t.jsxs)(s.p,{children:["Alias of ",(0,t.jsx)(i.R,{s:h.Vw.OrderStore(h.Ot.Glyph)}),"."]}),"\n",(0,t.jsxs)(s.h3,{children:["Interface ",(0,t.jsx)(i.Hf,{s:h.Ot.GlyphStoreFactory((0,o.l7)("GS",h.Ot.GlyphStore))})]}),"\n",(0,t.jsxs)(s.p,{children:["Alias of ",(0,t.jsx)(i.R,{s:h.Vw.OrderStoreFactory(h.Ot.Glyph,"GS")}),"."]}),"\n",(0,t.jsxs)(s.h3,{children:["Interface ",(0,t.jsx)(i.Hf,{s:h.Ot.GlyphStoreFactoryWithDefault((0,o.l7)("GS",h.Ot.GlyphStore))})]}),"\n",(0,t.jsxs)(s.p,{children:["Alias of ",(0,t.jsx)(i.R,{s:h.Vw.OrderStoreFactoryWithDefault(h.Ot.Glyph,"GS")}),"."]}),"\n",(0,t.jsxs)(s.h3,{children:["Type ",(0,t.jsx)(i.Hf,{s:h.Ot.ListGlyphStore})]}),"\n",(0,t.jsxs)(s.p,{children:["An opaque class that implements ",(0,t.jsx)(i.R,{s:h.Vw.OrderStore(h.Ot.Glyph)}),". Created by ",(0,t.jsx)(i.R,{s:h.Ot.ListGlyphStoreFactory}),"."]}),"\n",(0,t.jsxs)(s.h3,{children:["Singleton ",(0,t.jsx)(i.Hf,{s:h.Ot.ListGlyphStoreFactory})]}),"\n",(0,t.jsxs)(s.p,{children:["An opaque factory object that implements ",(0,t.jsx)(i.R,{s:h.Vw.OrderStoreFactoryWithDefault(h.Ot.Glyph,h.Ot.ListGlyphStore)}),"."]}),"\n",(0,t.jsx)(s.h2,{children:"Glyph"}),"\n",(0,t.jsxs)(s.h3,{children:["Class ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph})]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(i.R,{s:h.Ot.Glyph})," class represents one glyph. Object identity of ",(0,t.jsx)(i.R,{s:h.Ot.Glyph}),"'s carry the semantics of glyph identity. Many parts of the font, even some geometries inside the glyph, will hold references to ",(0,t.jsx)(i.R,{s:h.Ot.Glyph}),"'s."]}),"\n",(0,t.jsx)(s.h4,{children:"Constructor"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{ctor:!0,s:h.Ot.Glyph.constructor}),"\n",(0,t.jsxs)(s.p,{children:["Create an empty ",(0,t.jsx)(i.R,{s:h.Ot.Glyph}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.name,type:h.Vw.Maybe(h.Z_)}),"\n",(0,t.jsx)(s.p,{children:"The glyph name. Optional."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.geometry,type:h.Vw.Maybe(h.Ot.Glyph.Geometry)}),"\n",(0,t.jsx)(s.p,{children:"The geometry. Optional. When absent, the glyph is considered a space."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.hints,type:h.Vw.Maybe(h.Ot.Glyph.Hints)}),"\n",(0,t.jsx)(s.p,{children:"The hints. Optional."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.horizontal,type:h.Vw.Maybe(h.Ot.Glyph.Metric)}),"\n",(0,t.jsx)(s.p,{children:"The horizontal metric."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.vertical,type:h.Vw.Maybe(h.Ot.Glyph.Metric)}),"\n",(0,t.jsx)(s.p,{children:"The vertical metric."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Methods"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{static:!0,s:h.Ot.Glyph.shallowCopy,args:{from:h.Ot.Glyph},returns:h.Ot.Glyph}),"\n",(0,t.jsx)(s.p,{children:"Perform a shallow copy of another glyph."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{children:"Metrics"}),"\n",(0,t.jsxs)(s.h3,{children:["Datatype ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.Metric})]}),"\n",(0,t.jsx)(s.p,{children:"Defines a metric advance of a glyph."}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.Metric.start,type:h.Ot.Var.Value}),"\n",(0,t.jsx)(s.p,{children:"Start coordinate."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.Metric.end,type:h.Ot.Var.Value}),"\n",(0,t.jsx)(s.p,{children:"End coordinate."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{children:"Geometry"}),"\n",(0,t.jsxs)(s.h3,{children:["Interface ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.Geometry})]}),"\n",(0,t.jsx)(s.p,{children:"Defines as the union of the following cases."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.R,{s:h.Ot.Glyph.ContourSet}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.R,{s:h.Ot.Glyph.TtReference}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.R,{s:h.Ot.Glyph.GeometryList}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.GeometryT.type,type:"unique symbol"}),"\n",(0,t.jsx)(s.p,{children:"The type tag of this hint object."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Case Class ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.ContourSet})," | type = ",(0,t.jsx)(i.R,{s:h.Ot.Glyph.GeometryType.ContourSet})]}),"\n",(0,t.jsx)(s.h4,{children:"Implements"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.R,{s:h.Ot.Glyph.ContourSetProps}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Constructor"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{ctor:!0,s:h.Ot.Glyph.ContourSet.constructor,args:{},returns:h.Ot.Glyph.ContourSet}),"\n",(0,t.jsxs)(s.p,{children:["Creates an ",(0,t.jsx)(i.R,{s:h.Ot.Glyph.ContourSet})," with default implementation."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Interface ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.ContourSetProps})]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.ContourSetProps.contours,type:(0,h.IX)(h.Ot.Glyph.Contour)}),"\n",(0,t.jsx)(s.p,{children:"The contour set, being a nested array of control knots."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Case Class ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.TtReference})," | type = ",(0,t.jsx)(i.R,{s:h.Ot.Glyph.GeometryType.TtReference})]}),"\n",(0,t.jsx)(s.h4,{children:"Implements"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.R,{s:h.Ot.Glyph.TtReferenceProps}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Constructor"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{ctor:!0,long:!0,s:h.Ot.Glyph.TtReference.constructor,args:{to:(0,o.Fp)(h.Ot.Glyph,"Target glyph"),transform:(0,o.Fp)(h.Ot.Glyph.Transform2X3,"Transform of this reference")},returns:h.Ot.Glyph.TtReference}),"\n",(0,t.jsxs)(s.p,{children:["Creates an ",(0,t.jsx)(i.R,{s:h.Ot.Glyph.TrReference})," with default implementation."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Interface ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.TtReferenceProps})]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.TtReferenceProps.to,type:h.Ot.Glyph}),"\n",(0,t.jsx)(s.p,{children:"The target glyph."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.TtReferenceProps.transform,type:h.Ot.Glyph.Transform2X3}),"\n",(0,t.jsx)(s.p,{children:"The transform being applied."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.TtReferenceProps.roundXyToGrid,type:h.O7}),"\n",(0,t.jsx)(s.p,{children:"Whether to round to grid."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.TtReferenceProps.useMyMetrics,type:h.O7}),"\n",(0,t.jsx)(s.p,{children:"If set, this forces the advance width and left sidebearing for the composite to be equal to those from this original glyph. This works for hinted and unhinted characters."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.TtReferenceProps.pointAttachment,type:h.Vw.Maybe(h.Ot.Glyph.PointAttachment)}),"\n",(0,t.jsx)(s.p,{children:"When present, this reference follows TrueType's point-attachment rules."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Case Class ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.GeometryList})," | type = ",(0,t.jsx)(i.R,{s:h.Ot.Glyph.GeometryType.GeometryList})]}),"\n",(0,t.jsx)(s.h4,{children:"Implements"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.R,{s:h.Ot.Glyph.GeometryListProp}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Constructor"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{ctor:!0,s:h.Ot.Glyph.GeometryList.constructor,args:{items:(0,o.jt)((0,h.IX)(h.Ot.Glyph.Geometry))},returns:h.Ot.Glyph.GeometryList}),"\n",(0,t.jsxs)(s.p,{children:["Creates an ",(0,t.jsx)(i.R,{s:h.Ot.Glyph.GeometryList})," from its members."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Type ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.GeometryListProp})]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.GeometryList.items,type:h.Ot.Glyph.Geometry}),"\n",(0,t.jsx)(s.p,{children:"The sub items inside."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{children:"Hints"}),"\n",(0,t.jsxs)(s.h3,{children:["Interface ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.Hint})]}),"\n",(0,t.jsx)(s.p,{children:"Defines as the union of the following cases."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.R,{s:h.Ot.Glyph.TtInstruction}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.R,{s:h.Ot.Glyph.CffHint}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.Hint.type,type:"unique symbol"}),"\n",(0,t.jsx)(s.p,{children:"The type tag of this hint object."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Case Class ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.TtInstruction})," | type = ",(0,t.jsx)(i.R,{s:h.Ot.Glyph.HintType.TtInstruction})]}),"\n",(0,t.jsx)(s.h4,{children:"Implements"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.R,{s:h.Ot.Glyph.TtInstructionProps}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Constructor"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{ctor:!0,s:h.Ot.Glyph.TtInstruction.constructor,args:{instructions:"Buffer"}}),"\n",(0,t.jsxs)(s.p,{children:["Creates an ",(0,t.jsx)(i.R,{s:h.Ot.Glyph.TtInstruction})," from a given instruction buffer."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Interface ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.TtInstructionProps})]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.TtInstructionProps.instructions,type:"Buffer"}),"\n",(0,t.jsx)(s.p,{children:"The buffer containing the TrueType instructions."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Case Class ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.CffHint})," | type = ",(0,t.jsx)(i.R,{s:h.Ot.Glyph.HintType.CffHint})]}),"\n",(0,t.jsx)(s.h4,{children:"Implements"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.R,{s:h.Ot.Glyph.CffHintProps}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Constructor"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{ctor:!0,s:h.Ot.Glyph.CffHint.constructor,args:{},returns:h.Ot.Glyph.CffHint}),"\n",(0,t.jsxs)(s.p,{children:["Create an empty ",(0,t.jsx)(i.R,{s:h.Ot.Glyph.CffHint}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Interface ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.CffHintProps})]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.CffHintProps.hStems,type:h.Ot.Glyph.CffHintStem}),"\n",(0,t.jsx)(s.p,{children:"The horizontal stems."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.CffHintProps.vStems,type:h.Ot.Glyph.CffHintStem}),"\n",(0,t.jsx)(s.p,{children:"The vertical stems."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.CffHintProps.hintMasks,type:h.Ot.Glyph.CffHintMask}),"\n",(0,t.jsx)(s.p,{children:"The hint masks."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.CffHintProps.counterMasks,type:h.Ot.Glyph.CffHintMask}),"\n",(0,t.jsx)(s.p,{children:"The contour masks."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Datatype ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.CffHintStem})]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.CffHintStem.start,type:h.Ot.Var}),"\n",(0,t.jsx)(s.p,{children:"Start coordinate of this hint stem."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.CffHintStem.end,type:h.Ot.Var}),"\n",(0,t.jsx)(s.p,{children:"End coordinate of this hint stem."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Factory Methods"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Fn,{s:h.Ot.Glyph.CffHint.createStem,args:{start:h.Ot.Var.Value,end:h.Ot.Var.Value},returns:h.Ot.Glyph.CffHintStem}),"\n",(0,t.jsxs)(s.p,{children:["Create a ",(0,t.jsx)(i.R,{s:h.Ot.Glyph.CffHintStem}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Datatype ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.CffHintMask})]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.CffHintMask.at,type:(0,h.t8)(h.Ot.Glyph.PointRef)}),"\n",(0,t.jsx)(s.p,{children:"The point reference right before this hint mask take effect."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.CffHintMask.maskH,type:(0,h.t8)(h.Ot.Glyph.CffHintStem)}),"\n",(0,t.jsx)(s.p,{children:"Horizontal stems needed to be enabled."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.CffHintMask.maskH,type:(0,h.t8)(h.Ot.Glyph.CffHintStem)}),"\n",(0,t.jsx)(s.p,{children:"Vertical stems needed to be enabled."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Factory Methods"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Fn,{long:!0,s:h.Ot.Glyph.CffHint.createMask,args:{at:(0,o.Fp)(h.Ot.Glyph.PointRef,"Point reference right before this mask"),maskH:(0,o.Fp)((0,h.t8)(h.Ot.Glyph.CffHintStem),"Horizontal stems to be enabled"),maskV:(0,o.Fp)((0,h.t8)(h.Ot.Glyph.CffHintStem),"Vertical stems to be enabled")},returns:h.Ot.Glyph.CffHintMask}),"\n",(0,t.jsxs)(s.p,{children:["Create a ",(0,t.jsx)(i.R,{s:h.Ot.Glyph.CffHintMask}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{children:"Support Types"}),"\n",(0,t.jsxs)(s.h3,{children:["Datatype ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.Contour})]}),"\n",(0,t.jsxs)(s.p,{children:["Defined as ",(0,t.jsx)(i.R,{s:(0,h.IX)(h.Ot.Glyph.Point)}),"."]}),"\n",(0,t.jsxs)(s.h3,{children:["Datatype ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.Point})]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(i.R,{s:h.Ot.Glyph.Point})," defines the datatype of glyph points."]}),"\n",(0,t.jsx)(s.h4,{children:"Factory Methods"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{long:!0,static:!0,s:h.Ot.Glyph.Point.create,args:{x:(0,o.Fp)(h.Ot.Var.Value,"X Coordinate"),y:(0,o.Fp)(h.Ot.Var.Value,"Y coordinate"),kind:(0,o.jt)((0,o.Fp)(h.Ot.Glyph.PointType,"Point Type"))},returns:h.Ot.Glyph.Point}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.Point.x,type:h.Ot.Var.Value}),"\n",(0,t.jsx)(s.p,{children:"X coordinate."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.Point.y,type:h.Ot.Var.Value}),"\n",(0,t.jsx)(s.p,{children:"Y coordinate."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.Point.kind,type:h.Ot.Glyph.PointType}),"\n",(0,t.jsx)(s.p,{children:"Point type."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Singleton ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.PointOps})]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.PointOps.neutral,type:h.Rx}),"\n",(0,t.jsxs)(s.p,{children:["The identity of ",(0,t.jsx)(i.R,{s:h.Ot.Glyph.Point}),". Equal to 0."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Methods"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{s:h.Ot.Glyph.PointOps.add,args:{x:h.Ot.Glyph.Point,y:h.Ot.Glyph.Point},returns:h.Ot.Glyph.Point}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{s:h.Ot.Glyph.PointOps.negate,args:{x:h.Ot.Glyph.Point},returns:h.Ot.Glyph.Point}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{s:h.Ot.Glyph.PointOps.minus,args:{x:h.Ot.Glyph.Point,y:h.Ot.Glyph.Point},returns:h.Ot.Glyph.Point}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{s:h.Ot.Glyph.PointOps.scale,args:{scale:h.Rx,y:h.Ot.Glyph.Point},returns:h.Ot.Glyph.Point}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{s:h.Ot.Glyph.PointOps.addScale,args:{x:h.Ot.Glyph.Point,scale:h.Rx,y:h.Ot.Glyph.Point},returns:h.Ot.Glyph.Point}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{s:h.Ot.Glyph.PointOps.applyTransform,args:{x:h.Ot.Glyph.Point,transform:h.Ot.Glyph.Transform2X3},returns:h.Ot.Glyph.Point}),"\n",(0,t.jsx)(s.p,{children:"Apply a 2\xd73 transform to a point."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{s:h.Ot.Glyph.PointOps.combineTransform,args:{a:h.Ot.Glyph.Transform2X3,b:h.Ot.Glyph.Transform2X3},returns:h.Ot.Glyph.Transform2X3}),"\n",(0,t.jsxs)(s.p,{children:["Combine two 2\xd73 transforms together. Applying the combined transform will be equivalent to applying ",(0,t.jsx)(s.em,{children:"b"})," then ",(0,t.jsx)(s.em,{children:"a"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{s:h.Ot.Glyph.PointOps.removeScaledOffset,args:{tfm:h.Ot.Glyph.Transform2X3},returns:h.Ot.Glyph.Transform2X3}),"\n",(0,t.jsxs)(s.p,{children:["Create an equivalent 2\xd73 transform but without ",(0,t.jsx)(s.code,{children:"scaledOffset"})," property set."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Type ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.Transform2X3})]}),"\n",(0,t.jsx)(s.h4,{children:"Constants"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.Transform2X3.Identity,returns:h.Ot.Glyph.Transform2X3}),"\n",(0,t.jsx)(s.p,{children:"The identity transform."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Factory Methods"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Fn,{s:h.Ot.Glyph.Transform2X3.Scale,args:{s:h.Rx},returns:h.Ot.Glyph.Transform2X3}),"\n",(0,t.jsx)(s.p,{children:"Creates a uniform scaling transform."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Fn,{s:h.Ot.Glyph.Transform2X3.Translate,args:{dx:h.Ot.Var.Value,dy:h.Ot.Var.Value},returns:h.Ot.Glyph.Transform2X3}),"\n",(0,t.jsx)(s.p,{children:"Creates a translation transform."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Fn,{s:h.Ot.Glyph.Transform2X3.Rotate,args:{angle:h.Rx},returns:h.Ot.Glyph.Transform2X3}),"\n",(0,t.jsxs)(s.p,{children:["Creates a rotation transform. ",(0,t.jsx)(s.em,{children:"angle"})," is measured in radians, and the positive orientation is counter-clockwise."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.Transform2X3.dx,type:h.Ot.Var.Value}),"\n",(0,t.jsx)(s.p,{children:"X offset."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.Transform2X3.dy,type:h.Ot.Var.Value}),"\n",(0,t.jsx)(s.p,{children:"Y offset."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.Transform2X3.xx,type:h.Rx}),"\n",(0,t.jsx)(s.p,{children:"X scale."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.Transform2X3.yx,type:h.Rx}),"\n",(0,t.jsx)(s.p,{children:'X shearing. Used by the "Scale10" coefficient in TrueType\'s `glyf`` table.'}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.Transform2X3.xy,type:h.Rx}),"\n",(0,t.jsx)(s.p,{children:'Y shearing. Used by the "Scale01" coefficient in TrueType\'s `glyf`` table.'}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.Transform2X3.yy,type:h.Rx}),"\n",(0,t.jsx)(s.p,{children:"Y scale."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.Transform2X3.scaledOffset,type:h.Vw.Maybe(h.O7)}),"\n",(0,t.jsx)(s.p,{children:"Whether the offset is scaled."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Enumeration ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.PointType})]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(i.ck,{s:h.Ot.Glyph.PointType.Corner})," = 0"]}),"\n",(0,t.jsx)(s.p,{children:"This point is corner point."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(i.ck,{s:h.Ot.Glyph.PointType.Lead})," = 1"]}),"\n",(0,t.jsx)(s.p,{children:"This point is the first control point of a cubic Bezier curve."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(i.ck,{s:h.Ot.Glyph.PointType.Follow})," = 2"]}),"\n",(0,t.jsx)(s.p,{children:"This point is the second control point of a cubic Bezier curve."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(i.ck,{s:h.Ot.Glyph.PointType.Quad})," = 3"]}),"\n",(0,t.jsx)(s.p,{children:"This point is an off-curve control point in a quadratic contour, as in TrueType."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Datatype ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.PointRef})]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.PointRef.geometry,type:h.Rx}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.PointRef.contour,type:h.Rx}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.PointRef.index,type:h.Rx}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Datatype ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.PointIDRef})]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.PointIDRef.pointIndex,type:h.Rx}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Datatype ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.GlyphPointIDRef})]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.GlyphPointIDRef.glyph,type:h.Ot.Glyph}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.GlyphPointIDRef.pointIndex,type:h.Rx}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Datatype ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.PointAttachment})]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.PointAttachment.inner,type:h.Ot.Glyph.PointIDRef}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.Glyph.PointAttachment.outer,type:h.Ot.Glyph.PointIDRef}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{children:"Glyph Naming"}),"\n",(0,t.jsxs)(s.h3,{children:["Type ",(0,t.jsx)(i.Hf,{s:h.Ot.GlyphNamingSource})]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.GlyphNamingSource.post,type:h.Vw.Maybe(h.Vw.Naming.Source(h.Ot.Glyph))}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.GlyphNamingSource.cff,type:h.Vw.Maybe(h.Vw.Naming.Source(h.Ot.Glyph))}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{readonly:!0,s:h.Ot.GlyphNamingSource.encoding,type:h.Vw.Maybe(h.Vw.Naming.IndexSource(h.Ot.Glyph))}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Interface ",(0,t.jsx)(i.Hf,{s:h.Ot.GlyphNamer})]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{s:h.Ot.GlyphNamer.nameGlyph,args:{source:h.Ot.GlyphNamingSource,gid:h.Rx,glyph:h.Ot.Glyph},returns:h.Z_}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Singleton ",(0,t.jsx)(i.Hf,{s:h.Ot.StandardGlyphNamer})]}),"\n",(0,t.jsxs)(s.p,{children:["The default glyph namer, implements ",(0,t.jsx)(i.R,{s:h.Ot.GlyphNamer}),"."]}),"\n",(0,t.jsxs)(s.h2,{children:["Glyph Stats (namespace ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.Stats}),")"]}),"\n",(0,t.jsxs)(s.h3,{children:["Class ",(0,t.jsx)(i.Hf,{s:h.Ot.Glyph.Stats.BoundingBox})]}),"\n",(0,t.jsx)(s.h4,{children:"Constructor"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{ctor:!0,s:h.Ot.Glyph.Stats.BoundingBox.constructor,args:{xMin:h.Rx,xMax:h.Rx,yMin:h.Rx,yMax:h.Rx}}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.Stats.BoundingBox.xMin,type:h.Rx}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.Stats.BoundingBox.xMax,type:h.Rx}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.Stats.BoundingBox.yMin,type:h.Rx}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.Nw,{s:h.Ot.Glyph.Stats.BoundingBox.yMax,type:h.Rx}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{children:"Static Methods"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{static:!0,s:h.Ot.Glyph.Stats.BoundingBox.Blank,returns:h.Ot.Glyph.Stats.BoundingBox}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h2,{children:["Geometry Utilities (namespace ",(0,t.jsx)(i.Hf,{s:h.Ot.GeometryUtil}),")"]}),"\n",(0,t.jsxs)(s.h3,{children:["Interface ",(0,t.jsx)(i.Hf,{s:h.Ot.GeometryUtil.GeometrySink("T")})]}),"\n",(0,t.jsx)(s.h4,{children:"Methods"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{s:h.Ot.GeometryUtil.GeometrySink.beginContour}),"\n",(0,t.jsx)(s.p,{children:"The callback when a contour begins."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{s:h.Ot.GeometryUtil.GeometrySink.addControlKnot,args:{knot:h.Ot.Glyph.Point}}),"\n",(0,t.jsx)(s.p,{children:"The callback when a control knot (point) is added."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{s:h.Ot.GeometryUtil.GeometrySink.endContour}),"\n",(0,t.jsx)(s.p,{children:"The callback when a contour ends."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(i.n$,{s:h.Ot.GeometryUtil.GeometrySink.getResult,returns:"T"}),"\n",(0,t.jsx)(s.p,{children:"The callback of returning value."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{children:["Interface ",(0,t.jsx)(i.Hf,{s:h.Ot.GeometryUtil.GeometrySinkClass("T")})]}),"\n",(0,t.jsxs)(s.p,{children:["Class that constructs ",(0,t.jsx)(i.R,{s:h.Ot.GeometryUtil.GeometrySink("T")})," instances."]}),"\n",(0,t.jsxs)(s.h3,{children:["Class ",(0,t.jsx)(i.Hf,{s:h.Ot.GeometryUtil.Flattener})]}),"\n",(0,t.jsxs)(s.p,{children:["Implements ",(0,t.jsx)(i.R,{s:h.Ot.GeometryUtil.GeometrySink((0,h.IX)((0,h.IX)(h.Ot.Glyph.Point)))})]}),"\n",(0,t.jsx)(s.p,{children:"A sink class to flatten the geometry to a contour list."}),"\n",(0,t.jsxs)(s.h3,{children:["Class ",(0,t.jsx)(i.Hf,{s:h.Ot.GeometryUtil.ListPoint})]}),"\n",(0,t.jsxs)(s.p,{children:["Implements ",(0,t.jsx)(i.R,{s:h.Ot.GeometryUtil.GeometrySink((0,h.IX)(h.Ot.Glyph.Point))})]}),"\n",(0,t.jsx)(s.p,{children:"A sink class to list the geometry's points"}),"\n",(0,t.jsxs)(s.h3,{children:["Class ",(0,t.jsx)(i.Hf,{s:h.Ot.GeometryUtil.GetBound})]}),"\n",(0,t.jsxs)(s.p,{children:["Implements ",(0,t.jsx)(i.R,{s:h.Ot.GeometryUtil.GeometrySink(h.Ot.Glyph.Stat.BoundingBox)})]}),"\n",(0,t.jsx)(s.p,{children:"A sink class to get the bounding box of a geometry"}),"\n",(0,t.jsxs)(s.h3,{children:["Class ",(0,t.jsx)(i.Hf,{s:h.Ot.GeometryUtil.CountPoint})]}),"\n",(0,t.jsxs)(s.p,{children:["Implements ",(0,t.jsx)(i.R,{s:h.Ot.GeometryUtil.GeometrySink(h.Rx)})]}),"\n",(0,t.jsx)(s.p,{children:"A sink class to count the geometry's points."}),"\n",(0,t.jsxs)(s.h3,{children:["Function ",(0,t.jsx)(i.Fn,{s:h.Ot.GeometryUtil.apply("T"),args:{cls:h.Ot.GeometryUtil.GeometrySinkClass("T"),geometries:(0,o.RF)((0,h.IX)(h.Ot.Glyph.Geometry))},returns:"T"})]}),"\n",(0,t.jsx)(s.p,{children:"Traverse the geometries and use the sink to collect data."})]})}s.default=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(0,t.jsx)(p,Object.assign({},n,{children:(0,t.jsx)(c,n)}))}}},function(n){n.O(0,[774,495,888,179],function(){return n(n.s=2341)}),_N_E=n.O()}]);