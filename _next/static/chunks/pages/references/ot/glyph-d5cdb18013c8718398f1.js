_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[22],{NiWh:function(e,t,a){"use strict";a.r(t),a.d(t,"default",(function(){return s}));var l=a("Fcif"),n=a("dV/x"),p=a("mXGw"),r=a.n(p),c=a("/FXl"),d=a("/DYT"),y=a("uCIM"),b=a("hzWR"),o=a("q3Ca"),i=(r.a.createElement,{}),m=d.a;function s(e){var t=e.components,a=Object(n.a)(e,["components"]);return Object(c.a)(m,Object(l.a)({},i,a,{components:t,mdxType:"MDXLayout"}),Object(c.a)("h1",null,Object(c.a)(y.a,{s:b.d.Glyph,mdxType:"Decl"})),Object(c.a)("p",null,"The type-namespace duplex ",Object(c.a)(y.g,{s:b.d.Glyph,mdxType:"R"})," defines the datatype, related datatype and operations for OpenType glyphs."),Object(c.a)("h2",null,"Glyph Store"),Object(c.a)("p",null,"A ",Object(c.a)(y.g,{s:b.d.Font,mdxType:"R"})," support any datatypt implemented ",Object(c.a)(y.g,{s:b.b.OrderStore(b.d.Glyph),mdxType:"R"})," to be the glyph store. ",Object(c.a)("inlineCode",{parentName:"p"},"ot-builder")," provided ",Object(c.a)(y.g,{s:b.d.ListGlyphStore,mdxType:"R"})," as the default glyph store implementation."),Object(c.a)("h3",null,"Interface ",Object(c.a)(y.a,{s:b.d.GlyphStore,mdxType:"Decl"})),Object(c.a)("p",null,"Alias of ",Object(c.a)(y.g,{s:b.b.OrderStore(b.d.Glyph),mdxType:"R"}),"."),Object(c.a)("h3",null,"Interface ",Object(c.a)(y.a,{s:b.d.GlyphStoreFactory(Object(o.e)("GS",b.d.GlyphStore)),mdxType:"Decl"})),Object(c.a)("p",null,"Alias of ",Object(c.a)(y.g,{s:b.b.OrderStoreFactory(b.d.Glyph,"GS"),mdxType:"R"}),"."),Object(c.a)("h3",null,"Interface ",Object(c.a)(y.a,{s:b.d.GlyphStoreFactoryWithDefault(Object(o.e)("GS",b.d.GlyphStore)),mdxType:"Decl"})),Object(c.a)("p",null,"Alias of ",Object(c.a)(y.g,{s:b.b.OrderStoreFactoryWithDefault(b.d.Glyph,"GS"),mdxType:"R"}),"."),Object(c.a)("h3",null,"Type ",Object(c.a)(y.a,{s:b.d.ListGlyphStore,mdxType:"Decl"})),Object(c.a)("p",null,"An opaque class that implements ",Object(c.a)(y.g,{s:b.b.OrderStore(b.d.Glyph),mdxType:"R"}),". Created by ",Object(c.a)(y.g,{s:b.d.ListGlyphStoreFactory,mdxType:"R"}),"."),Object(c.a)("h3",null,"Singleton ",Object(c.a)(y.a,{s:b.d.ListGlyphStoreFactory,mdxType:"Decl"})),Object(c.a)("p",null,"An opaque factory object that implements ",Object(c.a)(y.g,{s:b.b.OrderStoreFactoryWithDefault(b.d.Glyph,b.d.ListGlyphStore),mdxType:"R"}),"."),Object(c.a)("h2",null,"Glyph"),Object(c.a)("h3",null,"Class ",Object(c.a)(y.a,{s:b.d.Glyph,mdxType:"Decl"})),Object(c.a)("p",null,"The ",Object(c.a)(y.g,{s:b.d.Glyph,mdxType:"R"})," class represents one glyph. Object identity of ",Object(c.a)(y.g,{s:b.d.Glyph,mdxType:"R"}),"'s carry the semantics of glyph identity. Many parts of the font, even some geometries inside the glyph, will hold references to ",Object(c.a)(y.g,{s:b.d.Glyph,mdxType:"R"}),"'s."),Object(c.a)("h4",null,"Implements"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.g,{s:b.d.Glyph.Props,mdxType:"R"}))),Object(c.a)("h4",null,"Constructor"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.e,{ctor:!0,s:b.d.Glyph.constructor,mdxType:"Method"}),Object(c.a)("p",{parentName:"li"}," Create a blank ",Object(c.a)(y.g,{s:b.d.Glyph,mdxType:"R"})," with default implementation."))),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.name,type:b.b.Maybe(b.o),mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The glyph name. Optional.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.geometry,type:b.b.Maybe(b.d.Glyph.Geometry),mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The geometry. Optional. When absent, the glyph is considered a space.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.hints,type:b.b.Maybe(b.d.Glyph.Hints),mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The hints. Optional.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.horizontal,type:b.b.Maybe(b.d.Glyph.Metric),mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The horizontal metric.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.vertical,type:b.b.Maybe(b.d.Glyph.Metric),mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The vertical metric."))),Object(c.a)("h3",null,"Datatype ",Object(c.a)(y.a,{s:b.d.Glyph.Props,mdxType:"Decl"})),Object(c.a)("p",null,"This datatype defines properties of ",Object(c.a)(y.g,{s:b.d.Glyph,mdxType:"R"}),"'s. This is a datatype therefore all the properties are ",Object(c.a)("em",{parentName:"p"},"read only"),"."),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.name,type:b.b.Maybe(b.o),mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The glyph name. Optional.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.geometry,type:b.b.Maybe(b.d.Glyph.Geometry),mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The geometry. Optional. When absent, the glyph is considered a space.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.hints,type:b.b.Maybe(b.d.Glyph.Hints),mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The hints. Optional.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.horizontal,type:b.b.Maybe(b.d.Glyph.Metric),mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The horizontal metric.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.vertical,type:b.b.Maybe(b.d.Glyph.Metric),mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The vertical metric."))),Object(c.a)("h2",null,"Metrics"),Object(c.a)("h3",null,"Datatype ",Object(c.a)(y.a,{s:b.d.Glyph.Metric,mdxType:"Decl"})),Object(c.a)("p",null,"Defines a metric advance of a glyph."),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.Metric.start,type:b.d.Var.Value,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," Start coordiante.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.Metric.end,type:b.d.Var.Value,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," End coordinate."))),Object(c.a)("h2",null,"Geometry"),Object(c.a)("h3",null,"Interface ",Object(c.a)(y.a,{s:b.d.Glyph.Geometry,mdxType:"Decl"})),Object(c.a)("p",null,"Defines as the union of the following cases."),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.g,{s:b.d.Glyph.ContourSet,mdxType:"R"})),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.g,{s:b.d.Glyph.TtReference,mdxType:"R"})),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.g,{s:b.d.Glyph.GeometryList,mdxType:"R"}))),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.GeometryT.type,type:"unique symbol",mdxType:"Member"}),Object(c.a)("p",{parentName:"li"},"The type tag of this hint object."))),Object(c.a)("h3",null,"Case Class ",Object(c.a)(y.a,{s:b.d.Glyph.ContourSet,mdxType:"Decl"})," | type = ",Object(c.a)(y.g,{s:b.d.Glyph.GeometryType.ContourSet,mdxType:"R"})),Object(c.a)("h4",null,"Implements"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.g,{s:b.d.Glyph.ContourSetProps,mdxType:"R"}))),Object(c.a)("h4",null,"Constructor"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.e,{ctor:!0,s:b.d.Glyph.ContourSet.constructor,args:{},returns:b.d.Glyph.ContourSet,mdxType:"Method"}),Object(c.a)("p",{parentName:"li"}," Creates an ",Object(c.a)(y.g,{s:b.d.Glyph.ContourSet,mdxType:"R"})," with default implementation."))),Object(c.a)("h3",null,"Interface ",Object(c.a)(y.a,{s:b.d.Glyph.ContourSetProps,mdxType:"Decl"})),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.ContourSetProps.contours,type:Object(b.i)(b.d.Glyph.Contour),mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The contour set, being a nested array of control knots."))),Object(c.a)("h3",null,"Case Class ",Object(c.a)(y.a,{s:b.d.Glyph.TtReference,mdxType:"Decl"})," | type = ",Object(c.a)(y.g,{s:b.d.Glyph.GeometryType.TtReference,mdxType:"R"})),Object(c.a)("h4",null,"Implements"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.g,{s:b.d.Glyph.TtReferenceProps,mdxType:"R"}))),Object(c.a)("h4",null,"Constructor"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.e,{ctor:!0,long:!0,s:b.d.Glyph.TtReference.constructor,args:{to:Object(o.a)(b.d.Glyph,"Target glyph"),transform:Object(o.a)(b.d.Glyph.Transform2X3,"Transform of this reference")},returns:b.d.Glyph.TtReference,mdxType:"Method"}),Object(c.a)("p",{parentName:"li"},"  Creates an ",Object(c.a)(y.g,{s:b.d.Glyph.TrReference,mdxType:"R"})," with default implementation."))),Object(c.a)("h3",null,"Interface ",Object(c.a)(y.a,{s:b.d.Glyph.TtReferenceProps,mdxType:"Decl"})),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.TtReferenceProps.to,type:b.d.Glyph,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The target glyph.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.TtReferenceProps.transform,type:b.d.Glyph.Transform2X3,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The transform being applied.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.TtReferenceProps.roundXyToGrid,type:b.j,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," Whether to round to grid.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.TtReferenceProps.useMyMetrics,type:b.j,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," If set, this forces the advance width and left sidebearing for the composite to be equal to those from this original glyph. This works for hinted and unhinted characters.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.TtReferenceProps.pointAttachment,type:b.b.Maybe(b.d.Glyph.PointAttachment),mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," When present, this reference follows TrueType's point-attachment rules."))),Object(c.a)("h3",null,"Case Class ",Object(c.a)(y.a,{s:b.d.Glyph.GeometryList,mdxType:"Decl"})," | type = ",Object(c.a)(y.g,{s:b.d.Glyph.GeometryType.GeometryList,mdxType:"R"})),Object(c.a)("h4",null,"Implements"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.g,{s:b.d.Glyph.GeometryListProp,mdxType:"R"}))),Object(c.a)("h4",null,"Constructor"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.e,{ctor:!0,s:b.d.Glyph.GeometryList.constructor,args:{items:Object(o.g)(Object(b.i)(b.d.Glyph.Geometry))},returns:b.d.Glyph.GeometryList,mdxType:"Method"}),Object(c.a)("p",{parentName:"li"}," Creates an ",Object(c.a)(y.g,{s:b.d.Glyph.GeometryList,mdxType:"R"})," from its members."))),Object(c.a)("h3",null,"Type ",Object(c.a)(y.a,{s:b.d.Glyph.GeometryListProp,mdxType:"Decl"})),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.GeometryList.items,type:b.d.Glyph.Geometry,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The sub items inside."))),Object(c.a)("h2",null,"Hints"),Object(c.a)("h3",null,"Interface ",Object(c.a)(y.a,{s:b.d.Glyph.Hint,mdxType:"Decl"})),Object(c.a)("p",null,"Defines as the union of the following cases."),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.g,{s:b.d.Glyph.TtInstruction,mdxType:"R"})),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.g,{s:b.d.Glyph.CffHint,mdxType:"R"}))),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.Hint.type,type:"unique symbol",mdxType:"Member"}),Object(c.a)("p",{parentName:"li"},"The type tag of this hint object."))),Object(c.a)("h3",null,"Case Class ",Object(c.a)(y.a,{s:b.d.Glyph.TtInstruction,mdxType:"Decl"})," | type = ",Object(c.a)(y.g,{s:b.d.Glyph.HintType.TtInstruction,mdxType:"R"})),Object(c.a)("h4",null,"Implements"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.g,{s:b.d.Glyph.TtInstructionProps,mdxType:"R"}))),Object(c.a)("h4",null,"Constructor"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.e,{ctor:!0,s:b.d.Glyph.TtInstruction.constructor,args:{instructions:"Buffer"},mdxType:"Method"}),Object(c.a)("p",{parentName:"li"}," Creates an ",Object(c.a)(y.g,{s:b.d.Glyph.TtInstruction,mdxType:"R"})," from a given instruction buffer."))),Object(c.a)("h3",null,"Interface ",Object(c.a)(y.a,{s:b.d.Glyph.TtInstructionProps,mdxType:"Decl"})),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.TtInstructionProps.instructions,type:"Buffer",mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The buffer containing the TrueType instructions."))),Object(c.a)("h3",null,"Case Class ",Object(c.a)(y.a,{s:b.d.Glyph.CffHint,mdxType:"Decl"})," | type = ",Object(c.a)(y.g,{s:b.d.Glyph.HintType.CffHint,mdxType:"R"})),Object(c.a)("h4",null,"Implements"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.g,{s:b.d.Glyph.CffHintProps,mdxType:"R"}))),Object(c.a)("h4",null,"Constructor"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.e,{ctor:!0,s:b.d.Glyph.CffHint.constructor,args:{},returns:b.d.Glyph.CffHint,mdxType:"Method"}),Object(c.a)("p",{parentName:"li"}," Create an empty ",Object(c.a)(y.g,{s:b.d.Glyph.CffHint,mdxType:"R"}),"."))),Object(c.a)("h3",null,"Interface ",Object(c.a)(y.a,{s:b.d.Glyph.CffHintProps,mdxType:"Decl"})),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.CffHintProps.hStems,type:b.d.Glyph.CffHintStem,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The horizontal stems.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.CffHintProps.vStems,type:b.d.Glyph.CffHintStem,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The vertical stems.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.CffHintProps.hintMasks,type:b.d.Glyph.CffHintMask,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The hint masks.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.CffHintProps.counterMasks,type:b.d.Glyph.CffHintMask,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The contour masks."))),Object(c.a)("h3",null,"Datatype ",Object(c.a)(y.a,{s:b.d.Glyph.CffHintStem,mdxType:"Decl"})),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.CffHintStem.start,type:b.d.Var,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," Start coordinate of this hint stem.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.CffHintStem.end,type:b.d.Var,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," End coordinate of this hint stem."))),Object(c.a)("h4",null,"Factory Methods"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.b,{s:b.d.Glyph.CffHint.createStem,args:{start:b.d.Var.Value,end:b.d.Var.Value},returns:b.d.Glyph.CffHintStem,mdxType:"Fn"}),Object(c.a)("p",{parentName:"li"}," Create a ",Object(c.a)(y.g,{s:b.d.Glyph.CffHintStem,mdxType:"R"}),"."))),Object(c.a)("h3",null,"Datatype ",Object(c.a)(y.a,{s:b.d.Glyph.CffHintMask,mdxType:"Decl"})),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.CffHintMask.at,type:Object(b.n)(b.d.Glyph.PointRef),mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The point reference right before this hint mask take effect.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.CffHintMask.maskH,type:Object(b.n)(b.d.Glyph.CffHintStem),mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," Horizontal stems needed to be enabled.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{s:b.d.Glyph.CffHintMask.maskH,type:Object(b.n)(b.d.Glyph.CffHintStem),mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," Vertical stems needed to be enabled."))),Object(c.a)("h4",null,"Factory Methods"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.b,{long:!0,s:b.d.Glyph.CffHint.createMask,args:{at:Object(o.a)(b.d.Glyph.PointRef,"Point reference right before this mask"),maskH:Object(o.a)(Object(b.n)(b.d.Glyph.CffHintStem),"Horizontal stems to be enabled"),maskV:Object(o.a)(Object(b.n)(b.d.Glyph.CffHintStem),"Vertical stems to be enabled")},returns:b.d.Glyph.CffHintMask,mdxType:"Fn"}),Object(c.a)("p",{parentName:"li"}," Create a ",Object(c.a)(y.g,{s:b.d.Glyph.CffHintMask,mdxType:"R"}),"."))),Object(c.a)("h2",null,"Support Types"),Object(c.a)("h3",null,"Datatype ",Object(c.a)(y.a,{s:b.d.Glyph.Contour,mdxType:"Decl"})),Object(c.a)("p",null,"Defined as ",Object(c.a)(y.g,{s:Object(b.i)(b.d.Glyph.Point),mdxType:"R"}),"."),Object(c.a)("h3",null,"Datatype ",Object(c.a)(y.a,{s:b.d.Glyph.Point,mdxType:"Decl"})),Object(c.a)(y.g,{s:b.d.Glyph.Point,mdxType:"R"})," defines the datatype of glyph points.",Object(c.a)("h4",null,"Factory Methods"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.e,{long:!0,static:!0,s:b.d.Glyph.Point.create,args:{x:Object(o.a)(b.d.Var.Value,"X Coordinate"),y:Object(o.a)(b.d.Var.Value,"Y coordinate"),kind:Object(o.g)(Object(o.a)(b.d.Glyph.PointType,"Point Type"))},returns:b.d.Glyph.Point,mdxType:"Method"}))),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.Point.x,type:b.d.Var.Value,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," X coordinate.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.Point.y,type:b.d.Var.Value,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," Y coordinate.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.Point.kind,type:b.d.Glyph.PointType,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," Point type."))),Object(c.a)("h3",null,"Singleton ",Object(c.a)(y.a,{s:b.d.Glyph.PointOps,mdxType:"Decl"})),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.PointOps.neutral,type:b.m,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," The identity of ",Object(c.a)(y.g,{s:b.d.Glyph.Point,mdxType:"R"}),". Equal to 0."))),Object(c.a)("h4",null,"Methods"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.e,{s:b.d.Glyph.PointOps.add,args:{x:b.d.Glyph.Point,y:b.d.Glyph.Point},returns:b.d.Glyph.Point,mdxType:"Method"})),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.e,{s:b.d.Glyph.PointOps.negate,args:{x:b.d.Glyph.Point},returns:b.d.Glyph.Point,mdxType:"Method"})),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.e,{s:b.d.Glyph.PointOps.minus,args:{x:b.d.Glyph.Point,y:b.d.Glyph.Point},returns:b.d.Glyph.Point,mdxType:"Method"})),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.e,{s:b.d.Glyph.PointOps.scale,args:{scale:b.m,y:b.d.Glyph.Point},returns:b.d.Glyph.Point,mdxType:"Method"})),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.e,{s:b.d.Glyph.PointOps.addScale,args:{x:b.d.Glyph.Point,scale:b.m,y:b.d.Glyph.Point},returns:b.d.Glyph.Point,mdxType:"Method"})),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.e,{s:b.d.Glyph.PointOps.applyTransform,args:{x:b.d.Glyph.Point,transform:b.d.Glyph.Transform2X3},returns:b.d.Glyph.Point,mdxType:"Method"}),Object(c.a)("p",{parentName:"li"},"Apply a 2\xd73 transform to a point.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.e,{s:b.d.Glyph.PointOps.combineTransform,args:{a:b.d.Glyph.Transform2X3,b:b.d.Glyph.Transform2X3},returns:b.d.Glyph.Transform2X3,mdxType:"Method"}),Object(c.a)("p",{parentName:"li"},"Combine two 2\xd73 transforms together. Applying the combined transform will be equivalent to applying ",Object(c.a)("em",{parentName:"p"},"b")," then ",Object(c.a)("em",{parentName:"p"},"a"),".")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.e,{s:b.d.Glyph.PointOps.removeScaledOffset,args:{tfm:b.d.Glyph.Transform2X3},returns:b.d.Glyph.Transform2X3,mdxType:"Method"}),Object(c.a)("p",{parentName:"li"},"Create an equivalent 2\xd73 transform but without ",Object(c.a)("inlineCode",{parentName:"p"},"scaledOffset")," property set."))),Object(c.a)("h3",null,"Type ",Object(c.a)(y.a,{s:b.d.Glyph.Transform2X3,mdxType:"Decl"})),Object(c.a)("h4",null,"Constants"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.a,{s:b.d.Glyph.Transform2X3.Identity,returns:b.d.Glyph.Transform2X3,mdxType:"Decl"}),Object(c.a)("p",{parentName:"li"},"The identity transform."))),Object(c.a)("h4",null,"Factory Methods"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.b,{s:b.d.Glyph.Transform2X3.Scale,args:{s:b.m},returns:b.d.Glyph.Transform2X3,mdxType:"Fn"}),Object(c.a)("p",{parentName:"li"},"Creates a uniform scaling transform.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.b,{s:b.d.Glyph.Transform2X3.Translate,args:{dx:b.d.Var.Value,dy:b.d.Var.Value},returns:b.d.Glyph.Transform2X3,mdxType:"Fn"}),Object(c.a)("p",{parentName:"li"},"Creates a translation transform.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.b,{s:b.d.Glyph.Transform2X3.Rotate,args:{angle:b.m},returns:b.d.Glyph.Transform2X3,mdxType:"Fn"}),Object(c.a)("p",{parentName:"li"},"Creates a rotation transform. ",Object(c.a)("em",{parentName:"p"},"angle")," is measured in radians, and the positive orientation is counter-colckwise."))),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.Transform2X3.dx,type:b.d.Var.Value,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"},"X offset.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.Transform2X3.dy,type:b.d.Var.Value,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"},"Y offset.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.Transform2X3.xx,type:b.m,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"},"X scale.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.Transform2X3.yx,type:b.m,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"},"X shearing.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.Transform2X3.xy,type:b.m,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"},"Y shearing.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.Transform2X3.yy,type:b.m,mdxType:"Member"}),Object(c.a)("p",{parentName:"li"},"Y scale.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.Transform2X3.scaledOffset,type:b.b.Maybe(b.j),mdxType:"Member"}),Object(c.a)("p",{parentName:"li"}," Whether the offset is scaled."))),Object(c.a)("h3",null,"Enumeration ",Object(c.a)(y.a,{s:b.d.Glyph.PointType,mdxType:"Decl"})),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.c,{s:b.d.Glyph.PointType.Corner,mdxType:"Item"})," = 0",Object(c.a)("p",{parentName:"li"}," This point is corner point.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.c,{s:b.d.Glyph.PointType.Lead,mdxType:"Item"})," = 1",Object(c.a)("p",{parentName:"li"}," This point is the first control point of a cubic Beizer curve.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.c,{s:b.d.Glyph.PointType.Follow,mdxType:"Item"})," = 2",Object(c.a)("p",{parentName:"li"}," This point is the second control point of a cubic Beizer curve.")),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.c,{s:b.d.Glyph.PointType.Quad,mdxType:"Item"})," = 3",Object(c.a)("p",{parentName:"li"}," This point is an off-curve control point in a quadratic contour, as in TrueType."))),Object(c.a)("h3",null,"Datatype ",Object(c.a)(y.a,{s:b.d.Glyph.PointRef,mdxType:"Decl"})),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.PointRef.geometry,type:b.m,mdxType:"Member"})),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.PointRef.contour,type:b.m,mdxType:"Member"})),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.PointRef.index,type:b.m,mdxType:"Member"}))),Object(c.a)("h3",null,"Datatype ",Object(c.a)(y.a,{s:b.d.Glyph.PointIDRef,mdxType:"Decl"})),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.PointIDRef.pointIndex,type:b.m,mdxType:"Member"}))),Object(c.a)("h3",null,"Datatype ",Object(c.a)(y.a,{s:b.d.Glyph.GlyphPointIDRef,mdxType:"Decl"})),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.GlyphPointIDRef.glyph,type:b.d.Glyph,mdxType:"Member"})),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.GlyphPointIDRef.pointIndex,type:b.m,mdxType:"Member"}))),Object(c.a)("h3",null,"Datatype ",Object(c.a)(y.a,{s:b.d.Glyph.PointAttachment,mdxType:"Decl"})),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.PointAttachment.inner,type:b.d.Glyph.PointIDRef,mdxType:"Member"})),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.Glyph.PointAttachment.outer,type:b.d.Glyph.PointIDRef,mdxType:"Member"}))),Object(c.a)("h2",null,"Glyph Naming"),Object(c.a)("h3",null,"Type ",Object(c.a)(y.a,{s:b.d.GlyphNamingSource,mdxType:"Decl"})),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.GlyphNamingSource.post,type:b.b.Maybe(b.b.Naming.Source(b.d.Glyph)),mdxType:"Member"})),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.GlyphNamingSource.cff,type:b.b.Maybe(b.b.Naming.Source(b.d.Glyph)),mdxType:"Member"})),Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.d,{readonly:!0,s:b.d.GlyphNamingSource.encoding,type:b.b.Maybe(b.b.Naming.IndexSource(b.d.Glyph)),mdxType:"Member"}))),Object(c.a)("h3",null,"Interface ",Object(c.a)(y.a,{s:b.d.GlyphNamer,mdxType:"Decl"})),Object(c.a)("h4",null,"Properties"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)(y.e,{s:b.d.GlyphNamer.nameGlyph,args:{source:b.d.GlyphNamingSource,gid:b.m,glyph:b.d.Glyph},returns:b.o,mdxType:"Method"}))),Object(c.a)("h3",null,"Singleton ",Object(c.a)(y.a,{s:b.d.StandardGlyphNamer,mdxType:"Decl"})),Object(c.a)("p",null,"The default glyph namer, implements ",Object(c.a)(y.g,{s:b.d.GlyphNamer,mdxType:"R"}),"."))}s.isMDXComponent=!0},n1IY:function(e,t,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/references/ot/glyph",function(){return a("NiWh")}])},q3Ca:function(e,t,a){"use strict";a.d(t,"g",(function(){return l})),a.d(t,"i",(function(){return n})),a.d(t,"d",(function(){return p})),a.d(t,"k",(function(){return r})),a.d(t,"b",(function(){return c})),a.d(t,"h",(function(){return d})),a.d(t,"j",(function(){return y})),a.d(t,"a",(function(){return b})),a.d(t,"e",(function(){return o})),a.d(t,"c",(function(){return i})),a.d(t,"f",(function(){return m}));var l=function(e){return{optional:e}},n=function(e){return{readonly:e}},p=function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];return{either:t}},r=function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];return{tuple:t}},c=function(e){for(var t=arguments.length,a=new Array(t>1?t-1:0),l=1;l<t;l++)a[l-1]=arguments[l];return{generic:e,args:a}},d=function(e,t){return{takes:e,returns:t}},y=function(e){return{object:e}},b=function(e,t){return{rawType:e,annotation:t}},o=function(e,t){return{operator:"extends",left:e,right:t}},i=function(e,t){return{operator:"=",left:e,right:t}},m=function(e,t){return{operator:"is",left:e,right:t}}}},[["n1IY",0,2,1,4,3]]]);